<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Análisis de brotes epidemiológicos</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-bf71b591a9d31b6585383f83b4bcc134.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<meta name="shinylive:serviceworker_dir" content=".">
<script src="index_files/libs/quarto-contrib/shinylive-0.9.1/shinylive/load-shinylive-sw.js" type="module"></script>
<script src="index_files/libs/quarto-contrib/shinylive-0.9.1/shinylive/run-python-blocks.js" type="module"></script>
<link href="index_files/libs/quarto-contrib/shinylive-0.9.1/shinylive/shinylive.css" rel="stylesheet">
<link href="index_files/libs/quarto-contrib/shinylive-quarto-css/shinylive-quarto.css" rel="stylesheet">


<link rel="stylesheet" href="custom.css">
</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Análisis de brotes epidemiológicos</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<pre class="shinylive-r" data-engine="r"><code>#| '!! shinylive warning !!': |
#|   shinylive does not work in self-contained HTML documents.
#|   Please set `embed-resources: false` in your metadata.
#| standalone: true
#| viewerHeight: 800
#| viewerWidth: 1500  # Aumenta este valor
#| layout: fill
#| fig-width: 100
#| fig-height: 700
#| code-fold: true
#| echo: false
#| warning: false
#| message: false

# if (!requireNamespace("munsell", quietly = TRUE)) {
#   install.packages("munsell", repos = "https://webr.r-wasm.org")
# }
library(munsell)

library(shiny)
library(bslib)
library(htmltools)
library(dplyr)
library(yaml)
library(readr)
library(shinyjs)
library(base64enc)

debug = FALSE

# =========================================================
# JAVASCRIPT PERSONALIZADO PARA DESCARGAS LOCALES
# =========================================================
# Este script crea un link invisible y descarga el contenido como un "Blob"
# Esto funciona incluso si el Service Worker está desactivado.
js_download_script &lt;- "
shinyjs.downloadFile = function(params) {
    var element = document.createElement('a');
    var blob = new Blob([params.content], {type: 'text/html'});
    element.setAttribute('href', window.URL.createObjectURL(blob));
    element.setAttribute('download', params.filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
};
"


# =========================
# FUNCIONES AUXILIARES
# =========================


colapsar_errores &lt;- function(x) {
  if (length(x) == 0) return("")
  paste("•", x, collapse = "\n")
}

determinar_tipo_variable &lt;- function(col, tipo_especificado = NA) {
  if (length(tipo_especificado) &gt; 1) {
    tipo_especificado &lt;- tipo_especificado[1]
  }
  
  if (length(tipo_especificado) &gt;= 1 &amp;&amp; !is.na(tipo_especificado[1])) {
    if (tipo_especificado[1] == "cuantitativa") return("cuantitativa")
    if (tipo_especificado[1] == "cualitativa") return("cualitativa")
  }
  
  if (!is.numeric(col)) return("cualitativa")
  
  valores_no_na &lt;- col[!is.na(col)]
  if (length(valores_no_na) == 0) return("cualitativa")
  
  n_unicos &lt;- length(unique(valores_no_na))
  if (n_unicos &lt;= 10) return("cualitativa")
  
  return("cuantitativa")
}


# =========================
# FUNCIÓN: CREAR VARIABLES INTERMEDIAS
# =========================

crear_variables_intermedias &lt;- function(datos, config_variables, vars_yaml = NULL) {
  datos_mod &lt;- datos
  
  if (!is.null(config_variables) &amp;&amp; !is.null(config_variables$calculo_edad)) {
    tryCatch({
      # Configuración para cálculo de edad
      config_edad &lt;- config_variables$calculo_edad
      
      # Obtener nombre de la variable de fecha de nacimiento
      if (!is.null(config_edad$fecha_nacimiento)) {
        var_fecha_nac &lt;- config_edad$fecha_nacimiento
        
        # Determinar fecha de referencia (fecha del brote)
        if (!is.null(config_edad$fecha_brote)) {
          # Posibilidad 1: fecha_brote es el nombre de una variable en los datos
          if (is.character(config_edad$fecha_brote) &amp;&amp; config_edad$fecha_brote %in% names(datos_mod)) {
            # Usar la fecha máxima de esa variable como fecha de referencia
            fecha_brote &lt;- max(as.Date(datos_mod[[config_edad$fecha_brote]]), na.rm = TRUE)
            message(sprintf("Usando fecha máxima de '%s' como referencia: %s", 
                           config_edad$fecha_brote, fecha_brote))
          } 
          # Posibilidad 2: fecha_brote es una fecha fija en formato string
          else if (is.character(config_edad$fecha_brote)) {
            tryCatch({
              fecha_brote &lt;- as.Date(config_edad$fecha_brote)
              message(sprintf("Usando fecha de brote fija: %s", fecha_brote))
            }, error = function(e) {
              # Si no se puede parsear como fecha y no es una columna, error
              fecha_brote &lt;&lt;- Sys.Date()
              warning(sprintf("No se pudo interpretar fecha_brote '%s'. Usando fecha actual.", 
                             config_edad$fecha_brote))
            })
          } else {
            # Posibilidad 3: fecha_brote podría ser una referencia a otra variable del YAML
            # (ej: variable de consumo o fecha de inicio)
            if (!is.null(vars_yaml)) {
              # Buscar variable de tiempo o consumo
              if (!is.null(vars_yaml$variable_tiempo_inicio) &amp;&amp; 
                  vars_yaml$variable_tiempo_inicio %in% names(datos_mod)) {
                fecha_brote &lt;- max(as.Date(datos_mod[[vars_yaml$variable_tiempo_inicio]]), na.rm = TRUE)
                message(sprintf("Usando fecha máxima de '%s' (variable_tiempo_inicio) como referencia: %s", 
                               vars_yaml$variable_tiempo_inicio, fecha_brote))
              } else if (!is.null(vars_yaml$exposicion)) {
                # Buscar entre las variables de exposición alguna que pueda ser fecha
                # (esto es más heurístico)
                fechas_posibles &lt;- character(0)
                for (exp in vars_yaml$exposicion) {
                  if (exp %in% names(datos_mod) &amp;&amp; 
                      any(grepl("fecha|date|consumo", tolower(exp)))) {
                    fechas_posibles &lt;- c(fechas_posibles, exp)
                  }
                }
                if (length(fechas_posibles) &gt; 0) {
                  # Tomar la primera fecha posible y usar su máximo
                  fecha_brote &lt;- max(as.Date(datos_mod[[fechas_posibles[1]]]), na.rm = TRUE)
                  message(sprintf("Usando fecha máxima de '%s' como referencia: %s", 
                                 fechas_posibles[1], fecha_brote))
                } else {
                  # Si no hay nada, usar fecha actual
                  fecha_brote &lt;- Sys.Date()
                  warning("No se pudo determinar fecha de referencia. Usando fecha actual.")
                }
              } else {
                fecha_brote &lt;- Sys.Date()
                warning("No se especificó fecha_brote válida en YAML. Usando fecha actual.")
              }
            } else {
              fecha_brote &lt;- Sys.Date()
              warning("No se pudo determinar fecha de referencia. Usando fecha actual.")
            }
          }
        } else {
          # Si no hay fecha_brote especificada
          if (!is.null(vars_yaml$variable_tiempo_inicio) &amp;&amp; 
              vars_yaml$variable_tiempo_inicio %in% names(datos_mod)) {
            fecha_brote &lt;- max(as.Date(datos_mod[[vars_yaml$variable_tiempo_inicio]]), na.rm = TRUE)
            message(sprintf("Usando fecha máxima de '%s' como referencia: %s", 
                           vars_yaml$variable_tiempo_inicio, fecha_brote))
          } else {
            fecha_brote &lt;- Sys.Date()
            warning("No se especificó fecha_brote. Usando fecha actual.")
          }
        }
        
        if (var_fecha_nac %in% names(datos_mod)) {
          # Convertir fecha de nacimiento a Date
          datos_mod[[var_fecha_nac]] &lt;- tryCatch({
            as.Date(datos_mod[[var_fecha_nac]])
          }, error = function(e) {
            # Intentar otros formatos comunes
            as.Date(datos_mod[[var_fecha_nac]], format = "%d/%m/%Y")
          })
          
          # Calcular edad en años
          datos_mod$calculo_edad &lt;- as.integer(
            floor(
              as.numeric(
                difftime(fecha_brote, datos_mod[[var_fecha_nac]], units = "days")
              ) / 365.25
            )
          )
          
          message(sprintf("Variable 'calculo_edad' creada usando fecha de referencia: %s", fecha_brote))
          
          # Verificar si hay edades negativas o extremas
          edades_negativas &lt;- sum(datos_mod$calculo_edad &lt; 0, na.rm = TRUE)
          if (edades_negativas &gt; 0) {
            warning(sprintf("Se encontraron %d edades negativas (posible error en fechas)", 
                           edades_negativas))
          }
          
          edades_extremas &lt;- sum(datos_mod$calculo_edad &gt; 120, na.rm = TRUE)
          if (edades_extremas &gt; 0) {
            warning(sprintf("Se encontraron %d edades &gt; 120 años (posible error en fechas)", 
                           edades_extremas))
          }
        }
      }
    }, error = function(e) {
      warning(sprintf("Error al crear calculo_edad: %s", e$message))
    })
  }
  
  # Crear grupo etario cada 5 años
  if (!is.null(config_variables$grupo_etario_5)) {
    tryCatch({
      # Obtener el nombre de la variable de edad desde la configuración
      var_edad_nombre &lt;- config_variables$grupo_etario_5$variable_edad
      
      if (is.null(var_edad_nombre)) {
        stop("No se especificó variable_edad para grupo_etario_5")
      }
      
      # Verificar que la variable existe en los datos
      if (!var_edad_nombre %in% names(datos_mod)) {
        stop(sprintf("Variable de edad '%s' no encontrada en los datos", var_edad_nombre))
      }
      
      edad_var &lt;- datos_mod[[var_edad_nombre]]
      var_nombre &lt;- var_edad_nombre
      
      # Eliminar valores NA
      edad_var_clean &lt;- edad_var[!is.na(edad_var)]
      if (length(edad_var_clean) == 0) {
        stop(sprintf("Variable '%s' no tiene valores válidos para crear grupos etarios", var_nombre))
      }
      
      # Asegurar que la edad sea numérica
      if (!is.numeric(edad_var)) {
        edad_var &lt;- as.numeric(edad_var)
      }
      
      # Calcular límites para los grupos
      edad_max &lt;- max(edad_var, na.rm = TRUE)
      breaks &lt;- seq(0, ceiling(edad_max / 5) * 5, by = 5)
      
      # Si la edad máxima es menor que el último break, ajustar
      if (edad_max &lt; max(breaks)) {
        breaks &lt;- breaks[breaks &lt;= ceiling(edad_max / 5) * 5]
      }
      
      # Asegurar que tenemos al menos 2 breaks
      if (length(breaks) &lt; 2) {
        breaks &lt;- c(0, 5)
      }
      
      # Crear grupos cada 5 años
      datos_mod$grupo_etario_5 &lt;- cut(
        edad_var,
        breaks = breaks,
        include.lowest = TRUE,
        right = FALSE,
        labels = paste0(breaks[-length(breaks)], "-", breaks[-1] - 1)
      )
      
      # Para el último grupo, usar formato especial si es abierto
      niveles &lt;- levels(datos_mod$grupo_etario_5)
      ultimo_nivel &lt;- niveles[length(niveles)]
      if (grepl(paste0(max(breaks) - 5, "-", max(breaks) - 1), ultimo_nivel)) {
        # Reemplazar último nivel con formato abierto
        niveles[length(niveles)] &lt;- paste0(max(breaks) - 5, "+")
        levels(datos_mod$grupo_etario_5) &lt;- niveles
      }
      
      message(sprintf("Variable 'grupo_etario_5' creada usando '%s'", var_nombre))
      
    }, error = function(e) {
      warning(sprintf("Error al crear grupo_etario_5: %s", e$message))
    })
  }
  
  # Crear grupo etario cada 10 años
  if (!is.null(config_variables$grupo_etario_10)) {
    tryCatch({
      # Obtener el nombre de la variable de edad desde la configuración
      var_edad_nombre &lt;- config_variables$grupo_etario_10$variable_edad
      
      if (is.null(var_edad_nombre)) {
        stop("No se especificó variable_edad para grupo_etario_10")
      }
      
      # Verificar que la variable existe en los datos
      if (!var_edad_nombre %in% names(datos_mod)) {
        stop(sprintf("Variable de edad '%s' no encontrada en los datos", var_edad_nombre))
      }
      
      edad_var &lt;- datos_mod[[var_edad_nombre]]
      var_nombre &lt;- var_edad_nombre
      
      # Eliminar valores NA
      edad_var_clean &lt;- edad_var[!is.na(edad_var)]
      if (length(edad_var_clean) == 0) {
        stop(sprintf("Variable '%s' no tiene valores válidos para crear grupos etarios", var_nombre))
      }
      
      # Asegurar que la edad sea numérica
      if (!is.numeric(edad_var)) {
        edad_var &lt;- as.numeric(edad_var)
      }
      
      # Calcular límites para los grupos
      edad_max &lt;- max(edad_var, na.rm = TRUE)
      breaks &lt;- seq(0, ceiling(edad_max / 10) * 10, by = 10)
      
      # Si la edad máxima es menor que el último break, ajustar
      if (edad_max &lt; max(breaks)) {
        breaks &lt;- breaks[breaks &lt;= ceiling(edad_max / 10) * 10]
      }
      
      # Asegurar que tenemos al menos 2 breaks
      if (length(breaks) &lt; 2) {
        breaks &lt;- c(0, 10)
      }
      
      # Crear grupos cada 10 años
      datos_mod$grupo_etario_10 &lt;- cut(
        edad_var,
        breaks = breaks,
        include.lowest = TRUE,
        right = FALSE,
        labels = paste0(breaks[-length(breaks)], "-", breaks[-1] - 1)
      )
      
      # Para el último grupo, usar formato especial si es abierto
      niveles &lt;- levels(datos_mod$grupo_etario_10)
      ultimo_nivel &lt;- niveles[length(niveles)]
      if (grepl(paste0(max(breaks) - 10, "-", max(breaks) - 1), ultimo_nivel)) {
        # Reemplazar último nivel con formato abierto
        niveles[length(niveles)] &lt;- paste0(max(breaks) - 10, "+")
        levels(datos_mod$grupo_etario_10) &lt;- niveles
      }
      
      message(sprintf("Variable 'grupo_etario_10' creada usando '%s'", var_nombre))
      
    }, error = function(e) {
      warning(sprintf("Error al crear grupo_etario_10: %s", e$message))
    })
  }
  
  return(datos_mod)
}
# =========================
# FUNCIÓN: DESCRIPCIÓN UNIVARIADA 
# =========================

generar_descripcion_univariada &lt;- function(datos, variables_sociodem, config_variables = NULL) {
  
  if (is.null(variables_sociodem) || length(variables_sociodem) == 0) {
    return(list(error = "No se definieron variables sociodemográficas"))
  }
  
  es_formato_nuevo &lt;- FALSE
  nombres_vars &lt;- character(0)
  tipos_vars &lt;- character(0)
  
  if (is.list(variables_sociodem) &amp;&amp; length(variables_sociodem) &gt; 0) {
    primer_elemento &lt;- variables_sociodem[[1]]
    
    if (is.list(primer_elemento) &amp;&amp; 
        "nombre" %in% names(primer_elemento) &amp;&amp; 
        "tipo" %in% names(primer_elemento)) {
      es_formato_nuevo &lt;- TRUE
      
      nombres_vars &lt;- sapply(variables_sociodem, function(x) x$nombre)
      tipos_vars &lt;- sapply(variables_sociodem, function(x) {
        tipo &lt;- x$tipo
        if (length(tipo) &gt; 1) tipo &lt;- tipo[1]
        return(tipo)
      })
    } else {
      nombres_vars &lt;- as.character(variables_sociodem)
      tipos_vars &lt;- rep(NA_character_, length(nombres_vars))
    }
  } else {
    nombres_vars &lt;- as.character(variables_sociodem)
    tipos_vars &lt;- rep(NA, length(nombres_vars))
  }
  
  # Verificar que las variables del YAML existen en los datos
  vars_faltantes &lt;- setdiff(nombres_vars, names(datos))
  if (length(vars_faltantes) &gt; 0) {
    return(list(error = paste("Variables no encontradas:", paste(vars_faltantes, collapse = ", "))))
  }
  
  # Incluir variables creadas automáticamente si existen en los datos
  # (calculo_edad, grupo_etario_5, grupo_etario_10)
  vars_creadas_posibles &lt;- c("calculo_edad", "grupo_etario_5", "grupo_etario_10")
  
  for (var_creada in vars_creadas_posibles) {
    if (var_creada %in% names(datos) &amp;&amp; !var_creada %in% nombres_vars) {
      nombres_vars &lt;- c(nombres_vars, var_creada)
      
      # Determinar tipo según la variable
      if (var_creada == "calculo_edad") {
        tipos_vars &lt;- c(tipos_vars, "cuantitativa")
      } else if (var_creada %in% c("grupo_etario_5", "grupo_etario_10")) {
        tipos_vars &lt;- c(tipos_vars, "cualitativa")
      } else {
        tipos_vars &lt;- c(tipos_vars, NA)
      }
    }
  }
  
  resultados &lt;- list()
  
  for (i in seq_along(nombres_vars)) {
    var &lt;- nombres_vars[i]
    tipo_especificado &lt;- if (es_formato_nuevo) tipos_vars[i] else NA
    col_original &lt;- datos[[var]]
    
    tipo_final &lt;- determinar_tipo_variable(col_original, tipo_especificado)
    
    col_procesada &lt;- col_original
    
    if (tipo_final == "cualitativa") {
      col_procesada &lt;- as.factor(col_procesada)
    } else if (tipo_final == "cuantitativa") {
      if (!is.numeric(col_procesada)) {
        col_numerica &lt;- suppressWarnings(as.numeric(col_procesada))
        if (!all(is.na(col_numerica[!is.na(col_procesada)]))) {
          col_procesada &lt;- col_numerica
        } else {
          tipo_final &lt;- "cualitativa"
          col_procesada &lt;- as.factor(col_original)
        }
      }
    }
    
    if (tipo_final == "cuantitativa") {
      n_validos &lt;- sum(!is.na(col_procesada))
      
      if (n_validos &gt; 0) {
        media_val &lt;- mean(col_procesada, na.rm = TRUE)
        mediana_val &lt;- median(col_procesada, na.rm = TRUE)
        sd_val &lt;- if (n_validos &gt; 1) sd(col_procesada, na.rm = TRUE) else NA
        min_val &lt;- min(col_procesada, na.rm = TRUE)
        max_val &lt;- max(col_procesada, na.rm = TRUE)
        q1_val &lt;- quantile(col_procesada, 0.25, na.rm = TRUE)
        q3_val &lt;- quantile(col_procesada, 0.75, na.rm = TRUE)
      } else {
        media_val &lt;- NA
        mediana_val &lt;- NA
        sd_val &lt;- NA
        min_val &lt;- NA
        max_val &lt;- NA
        q1_val &lt;- NA
        q3_val &lt;- NA
      }
      
      resultados[[var]] &lt;- list(
        variable = var,
        tipo = "numérica",
        tipo_original = class(col_original)[1],
        n = n_validos,
        n_faltantes = sum(is.na(col_procesada)),
        media = media_val,
        mediana = mediana_val,
        desv_std = sd_val,
        min = min_val,
        max = max_val,
        q1 = q1_val,
        q3 = q3_val
      )
    } else {
      if (!is.factor(col_procesada)) {
        col_procesada &lt;- as.factor(col_procesada)
      }
      
      n_validos &lt;- sum(!is.na(col_procesada))
      tabla &lt;- table(col_procesada, useNA = "ifany")
      
      resultados[[var]] &lt;- list(
        variable = var,
        tipo = "categórica",
        tipo_original = class(col_original)[1],
        n = n_validos,
        n_faltantes = sum(is.na(col_procesada)),
        n_categorias = length(levels(col_procesada)),
        categorias = levels(col_procesada),
        frecuencias = as.numeric(tabla),
        porcentajes = round(100 * prop.table(tabla), 1)
      )
    }
  }
  
  return(list(resultados = resultados, error = NULL))
}


# Función auxiliar para convertir resultados univariados a HTML para informe descargable
convertir_univariada_a_html &lt;- function(resultados) {
  if (!is.null(resultados$error)) {
    return("&lt;p class='alert alert-warning'&gt;Error: No hay datos disponibles&lt;/p&gt;")
  }
  
  html_parts &lt;- lapply(resultados$resultados, function(res) {
    if (res$tipo == "numérica") {
      sprintf("
        &lt;div style='margin-bottom: 20px;'&gt;
          &lt;h5&gt;&lt;strong&gt;%s&lt;/strong&gt; (numérica%s)&lt;/h5&gt;
          &lt;table class='table table-sm table-bordered' style='width: auto;'&gt;
            &lt;tbody&gt;
              &lt;tr&gt;&lt;td&gt;N válidos&lt;/td&gt;&lt;td&gt;%d&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;N faltantes&lt;/td&gt;&lt;td&gt;%d&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;Media&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;Mediana&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;Desvío Estándar&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;Mínimo&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;Máximo&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;Q1&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;Q3&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;/tr&gt;
            &lt;/tbody&gt;
          &lt;/table&gt;
        &lt;/div&gt;
      ",
      res$variable,
      if(!is.null(res$tipo_original)) paste0(", original: ", res$tipo_original) else "",
      res$n,
      res$n_faltantes,
      res$media,
      res$mediana,
      res$desv_std,
      res$min,
      res$max,
      res$q1,
      res$q3
      )
    } else {
      # Construir filas de la tabla
      filas_html &lt;- paste(sapply(seq_along(res$categorias), function(i) {
        sprintf("&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%d&lt;/td&gt;&lt;td&gt;%s%%&lt;/td&gt;&lt;/tr&gt;",
                as.character(res$categorias[i]),
                res$frecuencias[i],
                res$porcentajes[i])
      }), collapse = "\n")
      
      sprintf("
        &lt;div style='margin-bottom: 20px;'&gt;
          &lt;h5&gt;&lt;strong&gt;%s&lt;/strong&gt; (categórica%s, %d categorías)&lt;/h5&gt;
          &lt;table class='table table-sm table-bordered' style='width: auto;'&gt;
            &lt;thead&gt;
              &lt;tr&gt;&lt;th&gt;Categoría&lt;/th&gt;&lt;th&gt;Frecuencia&lt;/th&gt;&lt;th&gt;Porcentaje&lt;/th&gt;&lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
              %s
            &lt;/tbody&gt;
          &lt;/table&gt;
        &lt;/div&gt;
      ",
      res$variable,
      if(!is.null(res$tipo_original)) paste0(", original: ", res$tipo_original) else "",
      res$n_categorias,
      filas_html
      )
    }
  })
  
  return(paste(html_parts, collapse = "\n"))
}

# Función para convertir tasas de ataque a HTML (SOLO TASAS)
convertir_tasas_a_html &lt;- function(resultados_tasas) {
  if (is.null(resultados_tasas) || length(resultados_tasas) == 0) {
    return("&lt;p class='alert alert-warning'&gt;No se pudieron calcular tasas de ataque&lt;/p&gt;")
  }
  
  tablas_html &lt;- lapply(names(resultados_tasas), function(exposicion) {
    res &lt;- resultados_tasas[[exposicion]]
    
    sprintf("
      &lt;div style='margin-bottom: 25px;'&gt;
        &lt;h5&gt;&lt;strong&gt;%s&lt;/strong&gt; (n=%d)&lt;/h5&gt;
        &lt;table class='table table-sm table-bordered' style='width: auto;'&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;&lt;/th&gt;
              &lt;th&gt;Enfermos&lt;/th&gt;
              &lt;th&gt;Total&lt;/th&gt;
              &lt;th&gt;Tasa de ataque&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;strong&gt;Expuestos&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;%d&lt;/td&gt;
              &lt;td&gt;%d&lt;/td&gt;
              &lt;td&gt;%s&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;strong&gt;No expuestos&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;%d&lt;/td&gt;
              &lt;td&gt;%d&lt;/td&gt;
              &lt;td&gt;%s&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/div&gt;
    ",
    exposicion,
    res$n_total,
    res$casos_expuestos,
    res$n_expuestos,
    ifelse(!is.na(res$tasa_expuestos), sprintf("%.1f%%", res$tasa_expuestos * 100), "N/A"),
    res$casos_no_expuestos,
    res$n_no_expuestos,
    ifelse(!is.na(res$tasa_no_expuestos), sprintf("%.1f%%", res$tasa_no_expuestos * 100), "N/A")
    )
  })
  
  return(paste(tablas_html, collapse = "\n"))
}

# Función para convertir riesgo relativo a HTML
convertir_rr_a_html &lt;- function(resultados_rr) {
  if (is.null(resultados_rr) || length(resultados_rr) == 0) {
    return("&lt;p class='alert alert-warning'&gt;No se pudieron calcular riesgos relativos&lt;/p&gt;")
  }
  
  filas_html &lt;- sapply(names(resultados_rr), function(exposicion) {
    res &lt;- resultados_rr[[exposicion]]
    
    sprintf("&lt;tr&gt;&lt;td&gt;&lt;strong&gt;%s&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;",
            exposicion,
            res$riesgo_relativo,
            ifelse(!is.na(res$ic_95_inf), sprintf("[%.2f-%.2f]", res$ic_95_inf, res$ic_95_sup), "N/A"),
            res$diferencia_riesgo,
            ifelse(!is.na(res$p_valor), 
                   ifelse(res$p_valor &lt; 0.001, "&lt;0.001", sprintf("%.3f", res$p_valor)), 
                   "N/A")
    )
  })
  
  html_tabla &lt;- sprintf("
    &lt;table class='table table-sm table-bordered table-striped'&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Exposición&lt;/th&gt;
          &lt;th&gt;Riesgo Relativo&lt;/th&gt;
          &lt;th&gt;IC 95%%&lt;/th&gt;
          &lt;th&gt;Diferencia de Riesgo&lt;/th&gt;
          &lt;th&gt;Valor p&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        %s
      &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;div class='alert alert-info' style='margin-top: 15px;'&gt;
      &lt;small&gt;
        &lt;strong&gt;Interpretación:&lt;/strong&gt;
        RR &gt; 1: asociación positiva (mayor riesgo), RR &lt; 1: asociación negativa (menor riesgo), 
        RR = 1: no asociación. IC 95%% que no incluye 1 indica significancia estadística.
      &lt;/small&gt;
    &lt;/div&gt;
  ", paste(filas_html, collapse = "\n"))
  
  return(html_tabla)
}

# Función para convertir odds ratio a HTML para informe
convertir_or_a_html &lt;- function(resultados_or) {
  if (is.null(resultados_or) || length(resultados_or) == 0) {
    return("&lt;p class='alert alert-warning'&gt;No se pudieron calcular odds ratios&lt;/p&gt;")
  }
  
  filas_html &lt;- sapply(names(resultados_or), function(exposicion) {
    res &lt;- resultados_or[[exposicion]]
    
    sprintf("&lt;tr&gt;&lt;td&gt;&lt;strong&gt;%s&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;",
            exposicion,
            res$odds_ratio,
            ifelse(!is.na(res$ic_95_inf), sprintf("[%.2f-%.2f]", res$ic_95_inf, res$ic_95_sup), "N/A"),
            ifelse(!is.na(res$chi_cuadrado), sprintf("%.2f", res$chi_cuadrado), "N/A"),
            ifelse(!is.na(res$p_valor), 
                   ifelse(res$p_valor &lt; 0.001, "&lt;0.001", sprintf("%.3f", res$p_valor)), 
                   "N/A")
    )
  })
  
  html_tabla &lt;- sprintf("
    &lt;table class='table table-sm table-bordered table-striped'&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Exposición&lt;/th&gt;
          &lt;th&gt;Odds Ratio&lt;/th&gt;
          &lt;th&gt;IC 95%%&lt;/th&gt;
          &lt;th&gt;Chi²&lt;/th&gt;
          &lt;th&gt;Valor p&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
    &lt;/table&gt;
    &lt;div class='alert alert-info' style='margin-top: 15px;'&gt;
      &lt;small&gt;
        &lt;strong&gt;Interpretación:&lt;/strong&gt;
        OR &gt; 1: asociación positiva (mayor riesgo), OR &lt; 1: asociación negativa (menor riesgo), 
        OR = 1: no asociación. IC 95%% que no incluye 1 indica significancia estadística.
      &lt;/small&gt;
    &lt;/div&gt;
  ", paste(filas_html, collapse = "\n"))
  
  return(html_tabla)
}

# ===========================================================================
# NUEVAS FUNCIONES PARA FRECUENCIA_COMBINADA_SINTOMAS
# ===========================================================================

# Función para calcular frecuencia combinada de síntomas
calcular_frecuencia_combinada_sintomas &lt;- function(datos, vars_sintomas) {
  if (is.null(vars_sintomas) || length(vars_sintomas) == 0) {
    return(list(error = "No hay variables de síntomas definidas"))
  }
  
  # Extraer nombres de variables de síntomas
  nombres_sintomas &lt;- sapply(vars_sintomas, function(s) {
    if (is.list(s) &amp;&amp; !is.null(s$nombre)) {
      return(s$nombre)
    } else if (is.character(s)) {
      return(s)
    }
    return(NA)
  })
  
  # Filtrar NAs
  nombres_sintomas &lt;- nombres_sintomas[!is.na(nombres_sintomas)]
  
  # Verificar que las variables existan en los datos
  sintomas_validos &lt;- nombres_sintomas[nombres_sintomas %in% names(datos)]
  
  if (length(sintomas_validos) == 0) {
    return(list(error = "Ninguna variable de síntomas encontrada en los datos"))
  }
  
  # Convertir todas las variables a lógico
  datos_sintomas &lt;- datos[, sintomas_validos, drop = FALSE]
  datos_sintomas &lt;- as.data.frame(lapply(datos_sintomas, convertir_a_logico))
  
  # Crear combinaciones como string (ej: "fiebre + nauseas")
  datos_sintomas$combinacion &lt;- apply(datos_sintomas, 1, function(row) {
    sintomas_presentes &lt;- names(row)[row == TRUE &amp; !is.na(row)]
    if (length(sintomas_presentes) == 0) {
      return("Ningún síntoma")
    } else {
      return(paste(sintomas_presentes, collapse = " + "))
    }
  })
  
  # Contar frecuencias de cada combinación
  tabla_freq &lt;- as.data.frame(table(datos_sintomas$combinacion))
  colnames(tabla_freq) &lt;- c("Combinacion_sintomas", "Frecuencia")
  
  # Calcular porcentaje
  tabla_freq$Porcentaje &lt;- round(100 * tabla_freq$Frecuencia / sum(tabla_freq$Frecuencia), 2)
  
  # Ordenar de mayor a menor frecuencia
  tabla_freq &lt;- tabla_freq[order(-tabla_freq$Frecuencia), ]
  rownames(tabla_freq) &lt;- NULL
  
  return(tabla_freq)
}

calcular_frecuencia_simple_sintomas &lt;- function(datos, vars_sintomas) {
  
  if (is.null(vars_sintomas) || length(vars_sintomas) == 0) {
    return(list(error = "No hay variables de síntomas definidas"))
  }
  
  # ==============================
  # Extraer nombres de variables
  # ==============================
  
  nombres_sintomas &lt;- sapply(vars_sintomas, function(s) {
    if (is.list(s) &amp;&amp; !is.null(s$nombre)) {
      return(s$nombre)
    } else if (is.character(s)) {
      return(s)
    }
    return(NA)
  })
  
  nombres_sintomas &lt;- nombres_sintomas[!is.na(nombres_sintomas)]
  
  # ==============================
  # Verificar existencia en datos
  # ==============================
  
  sintomas_validos &lt;- nombres_sintomas[nombres_sintomas %in% names(datos)]
  
  if (length(sintomas_validos) == 0) {
    return(list(error = "Ninguna variable de síntomas encontrada en los datos"))
  }
  
  # ==============================
  # Convertir a lógico
  # ==============================
  
  datos_sintomas &lt;- datos[, sintomas_validos, drop = FALSE]
  datos_sintomas &lt;- as.data.frame(lapply(datos_sintomas, convertir_a_logico))
  
  # ==============================
  # Calcular frecuencia por síntoma
  # ==============================
  
  frecuencia &lt;- sapply(datos_sintomas, function(col) {
    sum(col == TRUE, na.rm = TRUE)
  })
  
  total_obs &lt;- nrow(datos_sintomas)
  
  porcentaje &lt;- round(100 * frecuencia / total_obs, 2)
  
  tabla_freq &lt;- data.frame(
    Sintoma = names(frecuencia),
    Frecuencia = as.numeric(frecuencia),
    Porcentaje = porcentaje,
    stringsAsFactors = FALSE
  )
  
  # ==============================
  # Ordenar de mayor a menor
  # ==============================
  
  tabla_freq &lt;- tabla_freq[order(-tabla_freq$Frecuencia), ]
  rownames(tabla_freq) &lt;- NULL
  
  return(tabla_freq)
}

convertir_frec_simple_sintomas_a_html &lt;- function(tabla_freq) {
  
  if (is.null(tabla_freq)) {
    return("&lt;p class='alert alert-warning'&gt;No se pudo calcular la frecuencia de síntomas&lt;/p&gt;")
  }
  
  if (!is.null(tabla_freq$error)) {
    return(sprintf("&lt;p class='alert alert-warning'&gt;%s&lt;/p&gt;", tabla_freq$error))
  }
  
  filas_html &lt;- apply(tabla_freq, 1, function(row) {
    sprintf("&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%.2f%%&lt;/td&gt;&lt;/tr&gt;",
            row["Sintoma"],
            row["Frecuencia"],
            as.numeric(row["Porcentaje"]))
  })
  
  html_tabla &lt;- sprintf("
    &lt;table class='table table-sm table-bordered table-striped'&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Síntoma&lt;/th&gt;
          &lt;th&gt;Frecuencia&lt;/th&gt;
          &lt;th&gt;Porcentaje&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        %s
      &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;div class='alert alert-info' style='margin-top: 15px;'&gt;
      &lt;small&gt;
        &lt;strong&gt;Nota:&lt;/strong&gt; Esta tabla muestra la frecuencia individual de cada síntoma entre los casos,
        ordenados de mayor a menor. Puede utilizarse como apoyo para la construcción de una definición de caso epidemiológica.
      &lt;/small&gt;
    &lt;/div&gt;
  ", paste(filas_html, collapse = "\n"))
  
  return(html_tabla)
}


# Función para convertir frecuencia combinada a HTML
convertir_frec_combinada_a_html &lt;- function(tabla_freq) {
  if (is.null(tabla_freq)) {
    return("&lt;p class='alert alert-warning'&gt;No se pudo calcular la frecuencia combinada de síntomas&lt;/p&gt;")
  }
  
  if (!is.null(tabla_freq$error)) {
    return(sprintf("&lt;p class='alert alert-warning'&gt;%s&lt;/p&gt;", tabla_freq$error))
  }
  
  filas_html &lt;- apply(tabla_freq, 1, function(row) {
    sprintf("&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%.2f%%&lt;/td&gt;&lt;/tr&gt;",
            row["Combinacion_sintomas"],
            row["Frecuencia"],
            as.numeric(row["Porcentaje"]))
  })
  
  html_tabla &lt;- sprintf("
    &lt;table class='table table-sm table-bordered table-striped'&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Combinación de síntomas&lt;/th&gt;
          &lt;th&gt;Frecuencia&lt;/th&gt;
          &lt;th&gt;Porcentaje&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        %s
      &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;div class='alert alert-info' style='margin-top: 15px;'&gt;
      &lt;small&gt;
        &lt;strong&gt;Nota:&lt;/strong&gt; Esta tabla muestra las combinaciones de síntomas presentes en los casos,
        ordenadas de mayor a menor frecuencia.
      &lt;/small&gt;
    &lt;/div&gt;
  ", paste(filas_html, collapse = "\n"))
  
  return(html_tabla)
}


render_univariada &lt;- function(resultados) {
  
  if (!is.null(resultados$error)) {
    return(div(
      class = "alert alert-warning",
      resultados$error
    ))
  }
  
  tablas &lt;- lapply(resultados$resultados, function(res) {
    
    if (res$tipo == "numérica") {
      tagList(
        h5(strong(res$variable), 
           " (numérica", 
           if(!is.null(res$tipo_original)) paste0(", original: ", res$tipo_original), 
           ")"),
        tags$table(
          class = "table table-sm table-bordered",
          style = "width: auto;",
          tags$tbody(
            tags$tr(tags$td("N válidos"), tags$td(res$n)),
            tags$tr(tags$td("N faltantes"), tags$td(res$n_faltantes)),
            tags$tr(tags$td("Media"), tags$td(round(res$media, 2))),
            tags$tr(tags$td("Mediana"), tags$td(round(res$mediana, 2))),
            tags$tr(tags$td("Desvío Estándar"), tags$td(round(res$desv_std, 2))),
            tags$tr(tags$td("Mínimo"), tags$td(round(res$min, 2))),
            tags$tr(tags$td("Máximo"), tags$td(round(res$max, 2))),
            tags$tr(tags$td("Q1"), tags$td(round(res$q1, 2))),
            tags$tr(tags$td("Q3"), tags$td(round(res$q3, 2)))
          )
        ),
        if (length(res$n_faltantes) == 1 &amp;&amp; res$n_faltantes &gt; 0) {
          div(
            class = "alert alert-light",
            style = "font-size: 0.8em; padding: 5px;",
            sprintf("%.1f%% de datos faltantes", 100 * res$n_faltantes / (res$n + res$n_faltantes))
          )
        }
      )
    } else {
      filas &lt;- lapply(seq_along(res$categorias), function(i) {
        tags$tr(
          tags$td(as.character(res$categorias[i])),
          tags$td(res$frecuencias[i]),
          tags$td(paste0(res$porcentajes[i], "%"))
        )
      })
      
      tagList(
        h5(strong(res$variable), 
           " (categórica", 
           if(!is.null(res$tipo_original)) paste0(", original: ", res$tipo_original), 
           ", ", res$n_categorias, " categorías)"),
        tags$table(
          class = "table table-sm table-bordered",
          style = "width: auto;",
          tags$thead(
            tags$tr(
              tags$th("Categoría"),
              tags$th("Frecuencia"),
              tags$th("Porcentaje")
            )
          ),
          tags$tbody(filas)
        ),
        if (res$n_faltantes &gt; 0) {
          div(
            class = "alert alert-light",
            style = "font-size: 0.8em; padding: 5px;",
            sprintf("%.1f%% de datos faltantes", 100 * res$n_faltantes / (res$n + res$n_faltantes))
          )
        }
      )
    }
  })
  
  tagList(
    div(
      class = "alert alert-info",
      tags$small(
        "Nota: Las variables se clasifican como 'categóricas' o 'numéricas' basándose en ",
        "la especificación del YAML o reglas heurísticas. ",
        "Variables numéricas con pocos valores únicos pueden tratarse como categóricas."
      )
    ),
    tablas
  )
}

# =========================
# FUNCIONES OPTIMIZADAS PARA TASAS DE ATAQUE Y RIESGO RELATIVO/ODDS RATIO
# =========================

# Optimización: Conversión a lógico más eficiente con vectorización
convertir_a_logico &lt;- function(x) {
  # Vectores de valores verdaderos y falsos (constantes)
  .true_vals &lt;- c("VERDADERO", "TRUE", "T", "SI", "SÍ", "YES", "Y", "1", "V", "S")
  .false_vals &lt;- c("FALSO", "FALSE", "F", "NO", "N", "0")
  
  if (is.logical(x)) return(x)
  if (is.numeric(x)) return(ifelse(x == 1, TRUE, ifelse(x == 0, FALSE, NA)))
  if (is.factor(x)) x &lt;- as.character(x)
  
  if (is.character(x)) {
    # Normalización eficiente en un solo paso
    x_norm &lt;- chartr("ÁÉÍÓÚ", "AEIOU", toupper(trimws(x)))
    result &lt;- rep(NA, length(x_norm))
    result[x_norm %in% .true_vals] &lt;- TRUE
    result[x_norm %in% .false_vals] &lt;- FALSE
    return(result)
  }
  
  return(as.logical(x))
}

# Optimización: Solo usar para debug, evitar en producción
analizar_valores_logicos &lt;- function(x, nombre = "variable") {
  if (!debug || !is.character(x)) return(invisible(NULL))
  cat(sprintf("\nValores únicos en '%s':\n", nombre))
  print(unique(toupper(trimws(x[!is.na(x)]))))
}

# OPTIMIZACIÓN: Función genérica para preparar datos 2x2 (evita duplicación)
preparar_datos_2x2 &lt;- function(datos, variable_evento, exposicion, variable_participo, debug) {
  if (debug) analizar_valores_logicos(datos[[exposicion]], exposicion)
  
  # Filtrar participantes si aplica (evita copias innecesarias)
  if (!is.null(variable_participo) &amp;&amp; variable_participo %in% names(datos)) {
    datos &lt;- datos[convertir_a_logico(datos[[variable_participo]]) == TRUE, ]
  }
  
  # Preparar datos (operación única, sin copias intermedias)
  evento_log &lt;- convertir_a_logico(datos[[variable_evento]])
  expos_log &lt;- convertir_a_logico(datos[[exposicion]])
  
  # Filtrar NAs de una vez
  validos &lt;- !is.na(evento_log) &amp; !is.na(expos_log)
  
  if (sum(validos) == 0) return(NULL)
  
  # Crear tabla 2x2
  tab &lt;- table(Exposicion = expos_log[validos], Evento = evento_log[validos])
  
  # Validar estructura
  if (nrow(tab) &lt; 2 || ncol(tab) &lt; 2) return(NULL)
  if (!("TRUE" %in% rownames(tab) &amp;&amp; "FALSE" %in% rownames(tab))) return(NULL)
  
  return(list(
    tabla = tab,
    a = tab["TRUE", "TRUE"],
    b = tab["TRUE", "FALSE"],
    c = tab["FALSE", "TRUE"],
    d = tab["FALSE", "FALSE"],
    n_total = sum(validos)
  ))
}

# MODIFICADO: Calcular solo tasas de ataque (sin RR ni diferencia de riesgo)
calcular_tasas_ataque &lt;- function(datos, variable_evento, variables_exposicion, variable_participo = NULL, debug = FALSE) {
  
  resultados &lt;- lapply(variables_exposicion, function(exposicion) {
    if (!exposicion %in% names(datos)) return(NULL)
    
    prep &lt;- preparar_datos_2x2(datos, variable_evento, exposicion, variable_participo, debug)
    if (is.null(prep)) return(NULL)
    
    n1 &lt;- prep$a + prep$b
    n0 &lt;- prep$c + prep$d
    
    list(
      tabla = prep$tabla,
      n_expuestos = n1,
      n_no_expuestos = n0,
      casos_expuestos = prep$a,
      casos_no_expuestos = prep$c,
      tasa_expuestos = if(n1 &gt; 0) prep$a / n1 else NA,
      tasa_no_expuestos = if(n0 &gt; 0) prep$c / n0 else NA,
      n_total = prep$n_total
    )
  })
  
  names(resultados) &lt;- variables_exposicion
  resultados[!sapply(resultados, is.null)]
}

# NUEVA FUNCIÓN OPTIMIZADA: Calcular riesgo relativo
calcular_riesgo_relativo &lt;- function(datos, variable_evento, variables_exposicion, variable_participo = NULL, debug = FALSE) {
  
  resultados &lt;- lapply(variables_exposicion, function(exposicion) {
    if (!exposicion %in% names(datos)) return(NULL)
    
    prep &lt;- preparar_datos_2x2(datos, variable_evento, exposicion, variable_participo, debug)
    if (is.null(prep)) return(NULL)
    
    n1 &lt;- prep$a + prep$b
    n0 &lt;- prep$c + prep$d
    
    p1 &lt;- if(n1 &gt; 0) prep$a / n1 else NA
    p0 &lt;- if(n0 &gt; 0) prep$c / n0 else NA
    
    rr &lt;- if(!is.na(p0) &amp;&amp; p0 &gt; 0) p1 / p0 else NA
    dr &lt;- if(!is.na(p1) &amp;&amp; !is.na(p0)) p1 - p0 else NA
    
    # IC 95% para RR (método de Katz)
    if (!is.na(rr) &amp;&amp; prep$a &gt; 0 &amp;&amp; prep$c &gt; 0) {
      se_log_rr &lt;- sqrt((1/prep$a - 1/n1) + (1/prep$c - 1/n0))
      log_rr &lt;- log(rr)
      li &lt;- exp(log_rr - 1.96 * se_log_rr)
      ls &lt;- exp(log_rr + 1.96 * se_log_rr)
    } else {
      li &lt;- NA
      ls &lt;- NA
    }
    
    # Chi-cuadrado y p-valor (optimizado)
    total &lt;- prep$n_total
    exp_a &lt;- n1 * (prep$a + prep$c) / total
    exp_b &lt;- n1 * (prep$b + prep$d) / total
    exp_c &lt;- n0 * (prep$a + prep$c) / total
    exp_d &lt;- n0 * (prep$b + prep$d) / total
    
    chi2 &lt;- sum(c(
      if(exp_a &gt; 0) (prep$a - exp_a)^2 / exp_a else 0,
      if(exp_b &gt; 0) (prep$b - exp_b)^2 / exp_b else 0,
      if(exp_c &gt; 0) (prep$c - exp_c)^2 / exp_c else 0,
      if(exp_d &gt; 0) (prep$d - exp_d)^2 / exp_d else 0
    ))
    
    list(
      tabla = prep$tabla,
      a = prep$a, b = prep$b, c = prep$c, d = prep$d,
      tasa_expuestos = p1,
      tasa_no_expuestos = p0,
      riesgo_relativo = rr,
      diferencia_riesgo = dr,
      ic_95_inf = li,
      ic_95_sup = ls,
      p_valor = pchisq(chi2, df = 1, lower.tail = FALSE),
      n_total = prep$n_total
    )
  })
  
  names(resultados) &lt;- variables_exposicion
  resultados[!sapply(resultados, is.null)]
}

# FUNCIÓN OPTIMIZADA: Calcular odds ratio
calcular_odds_ratio &lt;- function(datos, variable_evento, variables_exposicion, variable_participo = NULL, debug = FALSE) {
  
  resultados &lt;- lapply(variables_exposicion, function(exposicion) {
    if (!exposicion %in% names(datos)) return(NULL)
    
    prep &lt;- preparar_datos_2x2(datos, variable_evento, exposicion, variable_participo, debug)
    if (is.null(prep)) return(NULL)
    
    # Calcular OR
    or &lt;- if(prep$b &gt; 0 &amp;&amp; prep$c &gt; 0) (prep$a * prep$d) / (prep$b * prep$c) else NA
    
    # IC 95% para OR
    if (!is.na(or) &amp;&amp; prep$a &gt; 0 &amp;&amp; prep$b &gt; 0 &amp;&amp; prep$c &gt; 0 &amp;&amp; prep$d &gt; 0) {
      se_log_or &lt;- sqrt(1/prep$a + 1/prep$b + 1/prep$c + 1/prep$d)
      log_or &lt;- log(or)
      li &lt;- exp(log_or - 1.96 * se_log_or)
      ls &lt;- exp(log_or + 1.96 * se_log_or)
    } else {
      li &lt;- NA
      ls &lt;- NA
    }
    
    # Chi-cuadrado y p-valor (reutilizando lógica optimizada)
    total &lt;- prep$n_total
    n1 &lt;- prep$a + prep$b
    n0 &lt;- prep$c + prep$d
    
    exp_a &lt;- n1 * (prep$a + prep$c) / total
    exp_b &lt;- n1 * (prep$b + prep$d) / total
    exp_c &lt;- n0 * (prep$a + prep$c) / total
    exp_d &lt;- n0 * (prep$b + prep$d) / total
    
    chi2 &lt;- sum(c(
      if(exp_a &gt; 0) (prep$a - exp_a)^2 / exp_a else 0,
      if(exp_b &gt; 0) (prep$b - exp_b)^2 / exp_b else 0,
      if(exp_c &gt; 0) (prep$c - exp_c)^2 / exp_c else 0,
      if(exp_d &gt; 0) (prep$d - exp_d)^2 / exp_d else 0
    ))
    
    list(
      tabla = prep$tabla,
      a = prep$a, b = prep$b, c = prep$c, d = prep$d,
      odds_ratio = or,
      ic_95_inf = li,
      ic_95_sup = ls,
      chi_cuadrado = chi2,
      p_valor = pchisq(chi2, df = 1, lower.tail = FALSE),
      n_total = prep$n_total
    )
  })
  
  names(resultados) &lt;- variables_exposicion
  resultados[!sapply(resultados, is.null)]
}

# =========================
# FUNCIÓN OPTIMIZADA PARA FOREST PLOT (OR y RR)
# =========================

crear_forest_plot &lt;- function(resultados, tipo = "OR") {
  if (is.null(resultados) || length(resultados) == 0) {
    return(ggplot() + 
             annotate("text", x = 0.5, y = 0.5, 
                     label = "No hay datos para crear el forest plot", 
                     size = 6) +
             theme_void())
  }
  
  # Determinar campos y etiquetas según tipo (una sola vez)
  medida_campo &lt;- if(tipo == "OR") "odds_ratio" else "riesgo_relativo"
  titulo &lt;- paste0("Forest Plot - ", if(tipo == "OR") "Odds Ratios" else "Riesgos Relativos", " por Exposición")
  eje_x &lt;- paste0(if(tipo == "OR") "Odds Ratio" else "Riesgo Relativo", " (escala logarítmica)")
  caption_text &lt;- paste0("Líneas verticales representan intervalos de confianza al 95%\n",
                        tipo, " &gt; 1: mayor riesgo, ", tipo, " &lt; 1: menor riesgo")
  
  # Extraer datos de una vez (evitar múltiples llamadas a sapply)
  n &lt;- length(resultados)
  datos_plot &lt;- data.frame(
    Exposicion = names(resultados),
    Medida = vapply(resultados, function(x) x[[medida_campo]], numeric(1)),
    LI = vapply(resultados, function(x) x$ic_95_inf, numeric(1)),
    LS = vapply(resultados, function(x) x$ic_95_sup, numeric(1)),
    stringsAsFactors = FALSE
  )
  
  # Calcular significancia vectorialmente
  datos_plot$Significativo &lt;- (!is.na(datos_plot$LI) &amp; !is.na(datos_plot$LS)) &amp; 
                               (datos_plot$LI &gt; 1 | datos_plot$LS &lt; 1)
  
  # Ordenar y factorizar
  datos_plot &lt;- datos_plot[order(datos_plot$Medida, decreasing = TRUE), ]
  datos_plot$Exposicion &lt;- factor(datos_plot$Exposicion, levels = rev(datos_plot$Exposicion))
  
  # Límites del gráfico (cálculo eficiente)
  rango_valido &lt;- c(datos_plot$LI[!is.na(datos_plot$LI)], datos_plot$LS[!is.na(datos_plot$LS)])
  min_lim &lt;- max(0.05, min(c(rango_valido, 0.1), na.rm = TRUE) * 0.8)
  max_lim &lt;- min(20, max(c(rango_valido, 10), na.rm = TRUE) * 1.2)
  
  # Crear el forest plot
  p &lt;- ggplot(datos_plot, aes(x = Medida, y = Exposicion)) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "red", alpha = 0.7) +
    geom_errorbarh(aes(xmin = LI, xmax = LS, color = Significativo), 
                   height = 0.2, size = 1) +
    geom_point(aes(color = Significativo), size = 3, shape = 18) +
    scale_color_manual(values = c("FALSE" = "gray50", "TRUE" = "darkblue"), guide = "none") +
    scale_x_log10(limits = c(min_lim, max_lim),
                  breaks = c(0.1, 0.2, 0.5, 1, 2, 5, 10),
                  labels = c("0.1", "0.2", "0.5", "1", "2", "5", "10")) +
    geom_text(aes(label = sprintf("%.2f [%.2f-%.2f]", Medida, LI, LS), x = max_lim * 0.9), 
              hjust = 1, vjust = 0, size = 3.5, color = "black") +
    labs(title = titulo, x = eje_x, y = "Exposición", caption = caption_text) +
    theme_minimal(base_size = 12) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
      axis.title = element_text(face = "bold"),
      axis.text.y = element_text(size = 11),
      panel.grid.major = element_line(color = "gray90"),
      panel.grid.minor = element_blank(),
      plot.caption = element_text(size = 10, color = "gray50", hjust = 0)
    )
  
  return(p)
}

render_tabla_tasas &lt;- function(resultados_tasas) {
  if (is.null(resultados_tasas) || length(resultados_tasas) == 0) {
    return(div(
      class = "alert alert-warning",
      tags$h5("No se pudieron calcular tasas de ataque"),
      tags$p("Posibles causas:"),
      tags$ul(
        tags$li("Las variables no contienen valores lógicos (VERDADERO/FALSO, SI/NO, TRUE/FALSE, 1/0)"),
        tags$li("Faltan datos en las variables de evento o exposición"),
        tags$li("Las tablas 2x2 no pudieron construirse (no hay suficiente variación en los datos)"),
        tags$li("Verifique que las columnas en el CSV coincidan con las especificadas en el YAML")
      ),
      tags$p("Tip: Las variables lógicas deben usar valores como: VERDADERO/FALSO, SI/NO, TRUE/FALSE, 1/0")
    ))
  }
  
  tablas &lt;- lapply(names(resultados_tasas), function(exposicion) {
    res &lt;- resultados_tasas[[exposicion]]
    
    tagList(
      h5(strong(exposicion), sprintf(" (n=%d)", res$n_total)),
      tags$table(
        class = "table table-sm table-bordered",
        style = "width: auto; margin-bottom: 20px;",
        tags$thead(
          tags$tr(
            tags$th(""),
            tags$th("Enfermos"),
            tags$th("Total"),
            tags$th("Tasa de ataque")
          )
        ),
        tags$tbody(
          tags$tr(
            tags$td(strong("Expuestos")),
            tags$td(res$casos_expuestos),
            tags$td(res$n_expuestos),
            tags$td(ifelse(!is.na(res$tasa_expuestos), 
                          sprintf("%.1f%%", res$tasa_expuestos * 100), 
                          "N/A"))
          ),
          tags$tr(
            tags$td(strong("No expuestos")),
            tags$td(res$casos_no_expuestos),
            tags$td(res$n_no_expuestos),
            tags$td(ifelse(!is.na(res$tasa_no_expuestos), 
                          sprintf("%.1f%%", res$tasa_no_expuestos * 100), 
                          "N/A"))
          ),
          tags$tr(
            tags$td(strong("Riesgo Relativo (RR)")),
            tags$td(colspan = "3", 
                   ifelse(!is.na(res$riesgo_relativo), 
                          sprintf("%.2f", res$riesgo_relativo), 
                          "No calculable"))
          ),
          tags$tr(
            tags$td(strong("Diferencia de Riesgo")),
            tags$td(colspan = "3", 
                   ifelse(!is.na(res$diferencia_riesgo), 
                          sprintf("%.3f", res$diferencia_riesgo), 
                          "No calculable"))
          )
        )
      )
    )
  })
  
  tagList(tablas)
}

render_tabla_tasas &lt;- function(resultados_tasas) {
  if (is.null(resultados_tasas) || length(resultados_tasas) == 0) {
    return(div(
      class = "alert alert-warning",
      tags$h5("No se pudieron calcular tasas de ataque"),
      tags$p("Posibles causas:"),
      tags$ul(
        tags$li("Las variables no contienen valores lógicos (VERDADERO/FALSO, SI/NO, TRUE/FALSE, 1/0)"),
        tags$li("Faltan datos en las variables de evento o exposición"),
        tags$li("Las tablas 2x2 no pudieron construirse (no hay suficiente variación en los datos)"),
        tags$li("Verifique que las columnas en el CSV coincidan con las especificadas en el YAML")
      ),
      tags$p("Tip: Las variables lógicas deben usar valores como: VERDADERO/FALSO, SI/NO, TRUE/FALSE, 1/0")
    ))
  }
  
  tablas &lt;- lapply(names(resultados_tasas), function(exposicion) {
    res &lt;- resultados_tasas[[exposicion]]
    
    tagList(
      h5(strong(exposicion), sprintf(" (n=%d)", res$n_total)),
      tags$table(
        class = "table table-sm table-bordered",
        style = "width: auto; margin-bottom: 20px;",
        tags$thead(
          tags$tr(
            tags$th(""),
            tags$th("Enfermos"),
            tags$th("Total"),
            tags$th("Tasa de ataque")
          )
        ),
        tags$tbody(
          tags$tr(
            tags$td(strong("Expuestos")),
            tags$td(res$casos_expuestos),
            tags$td(res$n_expuestos),
            tags$td(ifelse(!is.na(res$tasa_expuestos), 
                          sprintf("%.1f%%", res$tasa_expuestos * 100), 
                          "N/A"))
          ),
          tags$tr(
            tags$td(strong("No expuestos")),
            tags$td(res$casos_no_expuestos),
            tags$td(res$n_no_expuestos),
            tags$td(ifelse(!is.na(res$tasa_no_expuestos), 
                          sprintf("%.1f%%", res$tasa_no_expuestos * 100), 
                          "N/A"))
          )
        )
      )
    )
  })
  
  tagList(tablas)
}

render_tabla_rr &lt;- function(resultados_rr) {
  if (is.null(resultados_rr) || length(resultados_rr) == 0) {
    return(div(
      class = "alert alert-warning",
      "No se pudieron calcular riesgos relativos"
    ))
  }
  
  filas &lt;- lapply(names(resultados_rr), function(exposicion) {
    res &lt;- resultados_rr[[exposicion]]
    
    tags$tr(
      tags$td(strong(exposicion)),
      tags$td(sprintf("%.2f", res$riesgo_relativo)),
      tags$td(ifelse(!is.na(res$ic_95_inf), sprintf("[%.2f-%.2f]", res$ic_95_inf, res$ic_95_sup), "N/A")),
      tags$td(sprintf("%.2f", res$diferencia_riesgo)),
      tags$td(ifelse(!is.na(res$p_valor), 
                    ifelse(res$p_valor &lt; 0.001, "&lt;0.001", sprintf("%.3f", res$p_valor)), 
                    "N/A"))
    )
  })
  
  tagList(
    tags$table(
      class = "table table-sm table-bordered table-striped",
      tags$thead(
        tags$tr(
          tags$th("Exposición"),
          tags$th("Riesgo Relativo"),
          tags$th("IC 95%"),
          tags$th("Diferencia de Riesgo"),
          tags$th("Valor p")
        )
      ),
      tags$tbody(filas)
    ),
    
    div(
      class = "alert alert-info mt-3",
      tags$small(
        strong("Interpretación:"),
        "RR &gt; 1: asociación positiva (mayor riesgo), RR &lt; 1: asociación negativa (menor riesgo), ",
        "RR = 1: no asociación. IC 95% que no incluye 1 indica significancia estadística."
      )
    )
  )
}

render_tabla_or &lt;- function(resultados_or) {
  if (is.null(resultados_or) || length(resultados_or) == 0) {
    return(div(
      class = "alert alert-warning",
      "No se pudieron calcular odds ratios"
    ))
  }
  
  filas &lt;- lapply(names(resultados_or), function(exposicion) {
    res &lt;- resultados_or[[exposicion]]
    
    tags$tr(
      tags$td(strong(exposicion)),
      tags$td(sprintf("%.2f", res$odds_ratio)),
      tags$td(ifelse(!is.na(res$ic_95_inf), sprintf("[%.2f-%.2f]", res$ic_95_inf, res$ic_95_sup), "N/A")),
      tags$td(ifelse(!is.na(res$chi_cuadrado), sprintf("%.2f", res$chi_cuadrado), "N/A")),
      tags$td(ifelse(!is.na(res$p_valor), 
                    ifelse(res$p_valor &lt; 0.001, "&lt;0.001", sprintf("%.3f", res$p_valor)), 
                    "N/A"))
    )
  })
  
  tagList(
    tags$table(
      class = "table table-sm table-bordered table-striped",
      tags$thead(
        tags$tr(
          tags$th("Exposición"),
          tags$th("Odds Ratio"),
          tags$th("IC 95%"),
          tags$th("Chi²"),
          tags$th("Valor p")
        )
      ),
      tags$tbody(filas)
    ),
    
    div(
      class = "alert alert-info mt-3",
      tags$small(
        strong("Interpretación:"),
        "OR &gt; 1: asociación positiva (mayor riesgo), OR &lt; 1: asociación negativa (menor riesgo), ",
        "OR = 1: no asociación. IC 95% que no incluye 1 indica significancia estadística."
      )
    )
  )
}

control_calidad_fechas &lt;- function(datos, vars_solicitud) {
  
  res &lt;- list(ok = TRUE, errores = character(0), advertencias = character(0), resumen = NULL)
  
  # Extraer variables desde el objeto de solicitud
  var_inicio &lt;- vars_solicitud$variable_tiempo_inicio
  var_ingesta &lt;- vars_solicitud$fecha_ingesta
  unidad &lt;- tolower(vars_solicitud$unidad_tiempo)
  
  # --- existencia ---
  if (!var_inicio %in% names(datos)) {
    res$ok &lt;- FALSE
    res$errores &lt;- c(res$errores, "No existe variable_tiempo_inicio en datos")
    return(res)
  }
  
  if (!is.null(var_ingesta) &amp;&amp; !var_ingesta %in% names(datos)) {
    res$ok &lt;- FALSE
    res$errores &lt;- c(res$errores, "No existe variable fecha_ingesta en datos")
    return(res)
  }
  
  x &lt;- datos[[var_inicio]]
  y &lt;- if (!is.null(var_ingesta)) datos[[var_ingesta]] else NULL
  
  # --- tipo según unidad ---
  if (unidad == "fecha") {
    
    if (!inherits(x, "Date")) {
      x2 &lt;- try(as.Date(x), silent = TRUE)
      if (inherits(x2, "try-error")) {
        res$ok &lt;- FALSE
        res$errores &lt;- c(res$errores, "variable_tiempo_inicio no es Date convertible")
        return(res)
      } else {
        x &lt;- x2
        res$advertencias &lt;- c(res$advertencias, "variable_tiempo_inicio convertida a Date")
      }
    }
    
    if (!is.null(y) &amp;&amp; !inherits(y, "Date")) {
      y2 &lt;- try(as.Date(y), silent = TRUE)
      if (inherits(y2, "try-error")) {
        res$ok &lt;- FALSE
        res$errores &lt;- c(res$errores, "fecha_ingesta no es Date convertible")
        return(res)
      } else {
        y &lt;- y2
        res$advertencias &lt;- c(res$advertencias, "fecha_ingesta convertida a Date")
      }
    }
  }
  
  if (unidad == "hora") {
    
    if (!(is.numeric(x) || inherits(x, "POSIXct"))) {
      res$ok &lt;- FALSE
      res$errores &lt;- c(res$errores, "variable_tiempo_inicio debe ser numérica o POSIXct")
      return(res)
    }
    
    if (!is.null(y) &amp;&amp; !(is.numeric(y) || inherits(y, "POSIXct"))) {
      res$ok &lt;- FALSE
      res$errores &lt;- c(res$errores, "fecha_ingesta debe ser numérica o POSIXct")
      return(res)
    }
  }
  
  # --- coherencia temporal ---
  if (!is.null(y)) {
    
    incub &lt;- x - y
    incub &lt;- incub[!is.na(incub)]
    
    if (length(incub) == 0) {
      res$ok &lt;- FALSE
      res$errores &lt;- c(res$errores, "No hay pares válidos para calcular incubación")
      return(res)
    }
    
    if (any(incub &lt; 0)) {
      res$advertencias &lt;- c(res$advertencias, "Existen incubaciones negativas (posible error en fechas)")
    }
    
    if (unidad == "hora" &amp;&amp; any(incub &gt; 720)) {
      res$advertencias &lt;- c(res$advertencias, "Incubaciones &gt;30 días detectadas")
    }
    
    res$resumen &lt;- list(
      n_validos = length(incub),
      mediana = median(incub, na.rm = TRUE),
      minimo = min(incub, na.rm = TRUE),
      maximo = max(incub, na.rm = TRUE)
    )
  }
  
  return(res)
}


calcular_incubacion &lt;- function(datos, vars_solicitud) {
  
  if (is.null(vars_solicitud$variable_tiempo_inicio) || is.null(vars_solicitud$unidad_tiempo)) {
    return(list(error = "No se definió variable_tiempo_inicio o unidad_tiempo en YAML"))
  }
  
  var_inicio &lt;- vars_solicitud$variable_tiempo_inicio
  unidad &lt;- tolower(vars_solicitud$unidad_tiempo)
  
  if (!var_inicio %in% names(datos)) {
    return(list(error = "La variable de inicio de síntomas no existe en los datos"))
  }
  
  # ---- Obtener tiempo de inicio ----
  inicio &lt;- datos[[var_inicio]]
  
  # ---- Obtener tiempo de ingesta ----
  if (!is.null(vars_solicitud$fecha_ingesta)) {
    
    # Si es nombre de variable
    if (vars_solicitud$fecha_ingesta %in% names(datos)) {
      ingesta &lt;- datos[[vars_solicitud$fecha_ingesta]]
    } else {
      # Si es valor fijo
      ingesta &lt;- rep(vars_solicitud$fecha_ingesta, length(inicio))
    }
    
  } else {
    return(list(error = "No se definió fecha_ingesta en YAML"))
  }
  
  # ---- Conversión según unidad ----
  if (unidad == "hora") {
    
    # Caso POSIX
    if (inherits(inicio, "POSIXct") || inherits(ingesta, "POSIXct")) {
      incubacion &lt;- as.numeric(difftime(inicio, ingesta, units = "hours"))
    } else {
      # Numérico (horas)
      incubacion &lt;- as.numeric(inicio) - as.numeric(ingesta)
    }
    
    unidad_salida &lt;- "horas"
    
  } else if (unidad == "fecha") {
    
    inicio &lt;- as.Date(inicio)
    ingesta &lt;- as.Date(ingesta)
    incubacion &lt;- as.numeric(inicio - ingesta)
    
    unidad_salida &lt;- "días"
    
  } else {
    return(list(error = "unidad_tiempo debe ser 'hora' o 'fecha'"))
  }
  
  # ---- Limpiar datos ----
  incubacion &lt;- incubacion[!is.na(incubacion)]
  incubacion &lt;- incubacion[incubacion &gt;= 0]
  
  if (length(incubacion) &lt; 3) {
    return(list(error = "No hay suficientes datos válidos para calcular incubación"))
  }
  
  # ---- Estadísticos ----
  mediana &lt;- median(incubacion)
  q1 &lt;- quantile(incubacion, 0.25)
  q3 &lt;- quantile(incubacion, 0.75)
  minimo &lt;- min(incubacion)
  maximo &lt;- max(incubacion)
  n &lt;- length(incubacion)
  
  # ---- Clasificación orientativa ----
  clasificacion &lt;- clasificar_incubacion(mediana, unidad_salida)
  
  return(list(
    mediana = round(mediana, 2),
    q1 = round(q1, 2),
    q3 = round(q3, 2),
    minimo = round(minimo, 2),
    maximo = round(maximo, 2),
    n = n,
    unidad = unidad_salida,
    clasificacion = clasificacion,
    # Mantener resumen para retrocompatibilidad
    resumen = list(
      Mediana = round(mediana, 2),
      Q1 = round(q1, 2),
      Q3 = round(q3, 2),
      Mínimo = round(minimo, 2),
      Máximo = round(maximo, 2),
      `N válidos` = n
    )
  ))
}

clasificar_incubacion &lt;- function(mediana, unidad) {
  
  if (unidad == "días") {
    mediana &lt;- mediana * 24
  }
  
  if (mediana &lt;= 6) {
    return("Compatible con toxinas preformadas (Staphylococcus aureus, Bacillus cereus emético)")
  } else if (mediana &lt;= 16) {
    return("Compatible con Clostridium perfringens / Bacillus cereus diarreico")
  } else if (mediana &lt;= 48) {
    return("Compatible con Salmonella / Norovirus")
  } else {
    return("Compatible con agentes de incubación prolongada (Campylobacter, E. coli, otros)")
  }
}


# OPTIMIZACIÓN: Función más eficiente para convertir gráficos a Base64
plot_to_b64 &lt;- function(p) {
  if (is.null(p)) return(NULL)
  
  tryCatch({
    tmp &lt;- tempfile(fileext = ".png")
    on.exit(unlink(tmp), add = TRUE)  # Asegurar limpieza
    
    # Configuración optimizada de ggsave
    ggsave(tmp, plot = p, width = 6, height = 4, dpi = 150, 
           device = "png", bg = "white")
    
    # Lectura y codificación eficiente
    file_size &lt;- file.info(tmp)$size
    raw_data &lt;- readBin(tmp, "raw", n = file_size)
    paste0("data:image/png;base64,", base64enc::base64encode(raw_data))
  }, error = function(e) {
    warning("Error al convertir gráfico a Base64: ", e$message)
    NULL
  })
}

logo_base64 &lt;- "data:image/gif;base64,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
"

# =========================
# UI
# =========================

ui &lt;- fluidPage(
  theme = bs_theme(version = 5, bootswatch = "flatly"),
  useShinyjs(),
  extendShinyjs(text = js_download_script, functions = c("downloadFile")),
  titlePanel(""),
  # 1. Inyección de CSS para posicionar el logo
  tags$head(
    tags$style(HTML("
      .logo-container {
        position: absolute;
        top: 15px;
        right: 25px;
        z-index: 1000;
      }
      .logo-container img {
        height: 40px; /* Puedes ajustar el tamaño aquí */
        width: auto;
      }
      /* Ajuste para que el título no choque con el logo en móviles */
      @media (max-width: 768px) {
        .logo-container { position: relative; float: right; margin-bottom: 10px; }
      }
    "))
  ),
  
  # 2. Contenedor del Logo
  tags$div(
    class = "logo-container",
    tags$img(src = logo_base64, alt = "Logo INE")
  ),
  sidebarLayout(
    sidebarPanel(
      width = 3,
      fileInput("datos", "1. Seleccionar datos (csv o txt)", accept = c(".csv", ".txt")),
      fileInput("yaml", "2. Seleccionar configuración (yaml)", accept = c(".yaml", ".yml")),
      #checkboxInput("debug", "Modo debug", value = FALSE),
      hr(),
      actionButton("ejecutar", "Generar informe", class = "btn-primary w-100"),
      actionButton("limpiar", "Limpiar todo", class = "btn-warning w-100 mt-2"),
      hr(),
      # Usamos un actionButton normal en lugar de downloadButton para mayor control
      hidden(
        actionButton("btn_descargar_js", "Descargar Informe HTML", class = "btn-success w-100")
      ),
      hr(),
      h5("Estado de carga:"),
      verbatimTextOutput("debug_info"),
      verbatimTextOutput("debug_tipos"),
      tags$p("INE 2026", 
         style = "font-size: 14px; color: #7f8c8d; font-style: italic; margin-top: 10px;")
    ),
    mainPanel(
      width = 9,
      uiOutput("mensajes"),
      uiOutput("resultado")
    )
  )
)

# =========================
# SERVER
# =========================

server &lt;- function(input, output, session) {
  
  estado &lt;- reactiveValues(
    datos = NULL,
    solicitud = NULL,
    ejecutado = FALSE,
    resultados_or = NULL,
    resultados_rr = NULL,  # NUEVO
    desc = NULL,
    resultados_tasas = NULL,
    grafico_or = NULL,
    grafico_rr = NULL,  # NUEVO
    grafico_curva = NULL,
    freq_combinada = NULL,
    freq_simple = NULL,
    incubacion = NULL,
    listo = FALSE
  )
  
  observeEvent(input$datos, {
    tryCatch({
      estado$datos &lt;- readr::read_delim(input$datos$datapath, delim = ";", 
                                locale = locale(decimal_mark = ","),
                                show_col_types = FALSE)
      # RESET CLAVE: Si cargan datos nuevos, el informe anterior desaparece
      estado$ejecutado &lt;- FALSE 
      showNotification("✓ Datos CSV cargados", type = "message")
    }, error = function(e) {
      tryCatch({
        estado$datos &lt;- readr::read_csv(input$datos$datapath, show_col_types = FALSE)
        showNotification("✓ Datos CSV cargados", type = "message")
      }, error = function(e2) {
        showNotification(paste("Error al leer CSV:", e2$message), type = "error")
        estado$datos &lt;- NULL
      })
    })
  })
  
  observeEvent(input$yaml, {
    tryCatch({
      estado$solicitud &lt;- yaml::read_yaml(input$yaml$datapath)
      estado$ejecutado &lt;- FALSE # RESET CLAVE
      showNotification("✓ YAML cargado", type = "message")
    }, error = function(e) {
      showNotification(paste("Error al leer YAML:", e$message), type = "error")
      estado$solicitud &lt;- NULL
    })
  })
  
  # BOTÓN LIMPIAR: Reset total
  observeEvent(input$limpiar, {
    estado$datos &lt;- NULL
    estado$solicitud &lt;- NULL
    estado$ejecutado &lt;- FALSE
    estado$resultados_or &lt;- NULL
    estado$resultados_rr &lt;- NULL
    estado$desc &lt;- NULL
    estado$resultados_tasas &lt;- NULL
    estado$grafico_or &lt;- NULL
    estado$grafico_rr &lt;- NULL
    estado$grafico_curva &lt;- NULL
    estado$freq_combinada &lt;- NULL
    estado$freq_simple &lt;- NULL
    estado$incubacion &lt;- NULL
    reset("datos")
    reset("yaml")
    showNotification("Vista limpiada", type = "warning")
  })

  
  errores_yaml &lt;- reactive({
    req(estado$solicitud)
    
    errores &lt;- c()
    
    if (is.null(estado$solicitud$definicion_problema)) {
      errores &lt;- c(errores, "Falta sección 'definicion_problema'")
    } else if (is.null(estado$solicitud$definicion_problema$evento)) {
      errores &lt;- c(errores, "Falta 'definicion_problema$evento'")
    }
    
    if (is.null(estado$solicitud$variables)) {
      errores &lt;- c(errores, "Falta sección 'variables'")
    }
    
    errores
  })
  
  errores_mapeo &lt;- reactive({
    req(estado$datos, estado$solicitud)
    
    if (is.null(estado$solicitud$variables)) {
      return(c())
    }
    
    vars_yaml &lt;- estado$solicitud$variables
    vars_datos &lt;- names(estado$datos)
    errores &lt;- c()
    
    if (!is.null(vars_yaml$sociodemograficas)) {
      for (var in vars_yaml$sociodemograficas) {
        
        var_nombre &lt;- if (is.list(var) &amp;&amp; "nombre" %in% names(var)) {
          var$nombre
        } else {
          var
        }
        
        if (!var_nombre %in% vars_datos) {
          errores &lt;- c(
            errores,
            paste("Variable sociodemográfica no encontrada:", var_nombre)
          )
        }
      }
    }
    
    if (!is.null(vars_yaml$variable_tiempo_inicio)) {
      var_inicio &lt;- vars_yaml$variable_tiempo_inicio
      if (!var_inicio %in% vars_datos) {
        errores &lt;- c(errores, paste("Variable de tiempo no encontrada:", var_inicio))
      }
    }
    
    if (!is.null(vars_yaml$evento)) {
      var_evento &lt;- vars_yaml$evento
      if (!var_evento %in% vars_datos) {
        errores &lt;- c(errores, paste("Variable de evento no encontrada:", var_evento))
      }
    }
    
    if (!is.null(vars_yaml$exposicion)) {
      for (var in vars_yaml$exposicion) {
        if (!var %in% vars_datos) {
          errores &lt;- c(errores, paste("Variable de exposición no encontrada:", var))
        }
      }
    }
    
    if (!is.null(vars_yaml$participo)) {
      var_participo &lt;- vars_yaml$participo
      if (!var_participo %in% vars_datos) {
        errores &lt;- c(errores, paste("Variable de participación no encontrada:", var_participo))
      }
    }
    
    errores
  })
  
  output$debug_tipos &lt;- renderPrint({
    req(estado$datos, estado$solicitud)
    
    datos &lt;- estado$datos
    vars_sociodem &lt;- estado$solicitud$variables$sociodemograficas
    
    cat("=== DEBUG: TIPOS DE VARIABLES ===\n")
    
    for (var in vars_sociodem) {
      if (is.list(var) &amp;&amp; "nombre" %in% names(var)) {
        var_nombre &lt;- var$nombre
        var_tipo &lt;- var$tipo
      } else {
        var_nombre &lt;- var
        var_tipo &lt;- "No especificado"
      }
      
      if (var_nombre %in% names(datos)) {
        col &lt;- datos[[var_nombre]]
        cat(sprintf("%s:\n", var_nombre))
        cat(sprintf("  Tipo YAML: %s\n", var_tipo))
        cat(sprintf("  Tipo R: %s\n", class(col)))
        cat(sprintf("  Valores únicos: %d\n", length(unique(na.omit(col)))))
        cat(sprintf("  Ejemplos: %s\n", paste(head(unique(col), 5), collapse=", ")))
        cat("  ---\n")
      }
    }
  })
  
  informe &lt;- eventReactive(input$ejecutar, {
    
    if (is.null(estado$datos)) {
      return(list(error = "Debe cargar un archivo CSV"))
    }
    
    if (is.null(estado$solicitud)) {
      return(list(error = "Debe cargar un archivo YAML"))
    }
    
    estado$ejecutado &lt;- TRUE # Se marca como ejecutado tras procesar
    
    err_yaml &lt;- errores_yaml()
    if (length(err_yaml) &gt; 0) {
      return(list(error = paste("Errores en YAML:\n", colapsar_errores(err_yaml))))
    }
    
    err_mapeo &lt;- errores_mapeo()
    if (length(err_mapeo) &gt; 0) {
      return(list(error = paste("Errores de mapeo:\n", colapsar_errores(err_mapeo))))
    }
    
    productos_esperados &lt;- estado$solicitud$productos
    productos &lt;- character(0)
    
    if (!is.null(productos_esperados) &amp;&amp; length(productos_esperados) &gt; 0) {
      productos &lt;- unlist(productos_esperados, use.names = FALSE)
    }
    
    
    # Crear variables intermedias si están configuradas
    datos_procesados &lt;- estado$datos
    
    # Verificar si hay configuración de variables creadas
    if (!is.null(estado$solicitud$variables_creadas)) {
      datos_procesados &lt;- crear_variables_intermedias(
        datos = datos_procesados,
        config_variables = estado$solicitud$variables_creadas,
        vars_yaml = estado$solicitud$variables  # Pasar las variables del YAML
      )
    }
    
    show("btn_descargar_js")
    
    list(
      datos = datos_procesados,
      vars = estado$solicitud$variables,
      evento = estado$solicitud$definicion_problema$evento,
      productos = productos,
      config_variables = estado$solicitud$variables_creadas,
      error = NULL
    )
  })
  
  output$mensajes &lt;- renderUI({
    req(input$ejecutar &gt; 0)
    
    info &lt;- informe()
    
    if (!is.null(info$error)) {
      div(
        class = "alert alert-danger",
        role = "alert",
        h4(class = "alert-heading", "❌ Error"),
        HTML(gsub("\n", "&lt;br&gt;", info$error))
      )
    } else {
      div(
        class = "alert alert-success",
        role = "alert",
        "✓ Informe generado correctamente"
      )
    }
  })
  
output$resultado &lt;- renderUI({
    if (!estado$ejecutado) return(NULL)
    req(input$ejecutar &gt; 0)
    
    info &lt;- informe()
    
    if (!is.null(info$error)) {
      return(NULL)
    }
    
    ev &lt;- info$evento
    productos &lt;- info$productos
    
    elementos &lt;- tagList(
      hr(),
      h2(ev$nombre, style = "color: #2c3e50;"),
      h4("Definición de caso"),
      p(ev$definicion_caso, style = "margin-left: 15px;"),
      h4("Población, lugar y período"),
      tags$ul(
        tags$li(strong("Población: "), ev$poblacion_en_riesgo),
        tags$li(strong("Lugar: "), ev$lugar),
        tags$li(strong("Período: "), ev$periodo_tiempo)
      ),
      hr()
    )
    
    if (length(productos) &gt; 0 &amp;&amp; "descripcion_univariada" %in% productos) {
      elementos &lt;- tagList(
        elementos,
        h3("Descripción univariada", style = "color: #34495e;"),
        uiOutput("tabla_univariada"),
        hr()
      )
    }
    
    if (length(productos) &gt; 0 &amp;&amp; "tasas_ataque_por_exposicion" %in% productos) {
      elementos &lt;- tagList(
        elementos,
        h3("Tasas de ataque por exposición", style = "color: #34495e;"),
        p("Análisis de tasas de ataque entre expuestos y no expuestos a cada alimento:"),
        uiOutput("tabla_tasas"),
        hr()
      )
    }
    
    # NUEVO: Riesgo relativo con forest plot
    if (length(productos) &gt; 0 &amp;&amp; "riesgo_relativo_por_exposicion" %in% productos) {
      elementos &lt;- tagList(
        elementos,
        h3("Riesgo relativo por exposición", style = "color: #34495e;"),
        p("Asociación entre exposición a alimentos y enfermedad (riesgo relativo):"),
        uiOutput("tabla_rr"),
        h3("Forest Plot de Riesgos Relativos", style = "color: #34495e;"),
        p("Visualización gráfica de los riesgos relativos con intervalos de confianza:"),
        plotOutput("forest_plot_rr", height = "600px"),
        hr()
      )
    }
    
    if (length(productos) &gt; 0 &amp;&amp; "odds_ratio_por_exposicion" %in% productos) {
      elementos &lt;- tagList(
        elementos,
        h3("Odds ratio por exposición", style = "color: #34495e;"),
        p("Asociación entre exposición a alimentos y enfermedad (odds ratio):"),
        uiOutput("tabla_or"),
        h3("Forest Plot de Odds Ratios", style = "color: #34495e;"),
        p("Visualización gráfica de los odds ratios con intervalos de confianza:"),
        plotOutput("forest_plot_or", height = "600px"),
        hr()
      )
    }
    
    if (length(productos) &gt; 0 &amp;&amp; "curva_epidemica" %in% productos) {
      elementos &lt;- tagList(
        elementos,
        h3("Curva epidémica", style = "color: #34495e;"),
        plotOutput("plot_curva", height = "450px"),
        hr()
      )
    }

    if (length(productos) &gt; 0 &amp;&amp; "frecuencia_simple_sintomas" %in% productos) {
      elementos &lt;- tagList(
        elementos,
        h3("Frecuencia simple de síntomas", style = "color: #34495e;"),
        p("Síntomas presentes en los casos:"),
        uiOutput("tabla_freq_simple"),
        hr()
      )
    }
    
    if (length(productos) &gt; 0 &amp;&amp; "frecuencia_combinada_sintomas" %in% productos) {
      elementos &lt;- tagList(
        elementos,
        h3("Frecuencia combinada de síntomas", style = "color: #34495e;"),
        p("Combinaciones de síntomas presentes en los casos:"),
        uiOutput("tabla_freq_combinada"),
        hr()
      )
    }
    
    if (length(productos) &gt; 0 &amp;&amp; "incubacion" %in% productos) {
      elementos &lt;- tagList(
        elementos,
        h3("Incubación", style = "color: #34495e;"),
        p("Resumen tiempo de incubación:"),
        uiOutput("tabla_incubacion"),
        hr()
      )
    }
    
    return(elementos)
  })
  
  output$tabla_univariada &lt;- renderUI({
    req(input$ejecutar &gt; 0)
    
    info &lt;- informe()
    
    if (!is.null(info$error)) return(NULL)
    
    vars_sociodem &lt;- info$vars$sociodemograficas
    
    if (is.null(vars_sociodem)) {
      return(div(
        class = "alert alert-warning",
        "No se definieron variables sociodemográficas en el YAML"
      ))
    }
    
    desc &lt;- generar_descripcion_univariada(
      datos = info$datos, 
      variables_sociodem = vars_sociodem,
      config_variables = info$config_variables
    )
    
    estado$desc &lt;- desc
    
    render_univariada(desc)
    
  })
  
  output$tabla_tasas &lt;- renderUI({
    req(input$ejecutar &gt; 0)
    
    info &lt;- informe()
    
    if (!is.null(info$error)) return(NULL)
    
    vars &lt;- info$vars
    
    if (is.null(vars$evento) || is.null(vars$exposicion)) {
      return(div(
        class = "alert alert-warning",
        "Faltan definiciones de evento o exposiciones en el YAML"
      ))
    }
    
    variable_evento &lt;- vars$evento
    variables_exposicion &lt;- vars$exposicion
    variable_participo &lt;- vars$participo
    
    if (!variable_evento %in% names(info$datos)) {
      return(div(
        class = "alert alert-warning",
        paste("Variable de evento no encontrada:", variable_evento)
      ))
    }
    
    if (debug) {
      cat("\n=== DEBUG TASAS DE ATAQUE ===\n")
      cat("Variable evento:", variable_evento, "\n")
      cat("Variable participo:", variable_participo, "\n")
      cat("Exposiciones:", paste(variables_exposicion, collapse=", "), "\n")
      
      datos &lt;- info$datos
      cat("\nValores únicos en", variable_evento, ":\n")
      print(table(datos[[variable_evento]], useNA = "always"))
      
      if (!is.null(variable_participo)) {
        cat("\nValores únicos en", variable_participo, ":\n")
        print(table(datos[[variable_participo]], useNA = "always"))
      }
    }
    
    resultados_tasas &lt;- calcular_tasas_ataque(
      datos = info$datos,
      variable_evento = variable_evento,
      variables_exposicion = variables_exposicion,
      variable_participo = variable_participo,
      debug = FALSE #input$debug
    )
    
    estado$resultados_tasas &lt;- resultados_tasas
    
    render_tabla_tasas(resultados_tasas)
  })
  
 # NUEVO: Output para riesgo relativo
  output$tabla_rr &lt;- renderUI({
    req(input$ejecutar &gt; 0)
    
    info &lt;- informe()
    
    if (!is.null(info$error)) return(NULL)
    
    vars &lt;- info$vars
    
    if (is.null(vars$evento) || is.null(vars$exposicion)) {
      return(div(
        class = "alert alert-warning",
        "Faltan definiciones de evento o exposiciones en el YAML"
      ))
    }
    
    variable_evento &lt;- vars$evento
    variables_exposicion &lt;- vars$exposicion
    variable_participo &lt;- vars$participo
    
    if (!variable_evento %in% names(info$datos)) {
      return(div(
        class = "alert alert-warning",
        paste("Variable de evento no encontrada:", variable_evento)
      ))
    }
    
    resultados_rr &lt;- calcular_riesgo_relativo(
      datos = info$datos,
      variable_evento = variable_evento,
      variables_exposicion = variables_exposicion,
      variable_participo = variable_participo,
      debug = FALSE
    )
    
    estado$resultados_rr &lt;- resultados_rr
    
    render_tabla_rr(resultados_rr)
  })
  
  
  
  
  output$tabla_or &lt;- renderUI({
    req(input$ejecutar &gt; 0)
    
    info &lt;- informe()
    
    if (!is.null(info$error)) return(NULL)
    
    vars &lt;- info$vars
    
    if (is.null(vars$evento) || is.null(vars$exposicion)) {
      return(div(
        class = "alert alert-warning",
        "Faltan definiciones de evento o exposiciones en el YAML"
      ))
    }
    
    variable_evento &lt;- vars$evento
    variables_exposicion &lt;- vars$exposicion
    variable_participo &lt;- vars$participo
    
    if (!variable_evento %in% names(info$datos)) {
      return(div(
        class = "alert alert-warning",
        paste("Variable de evento no encontrada:", variable_evento)
      ))
    }
    
    if (debug) {
      cat("\n=== DEBUG ODDS RATIO ===\n")
      cat("Variable evento:", variable_evento, "\n")
      cat("Variable participo:", variable_participo, "\n")
      cat("Exposiciones:", paste(variables_exposicion, collapse=", "), "\n")
      
      datos &lt;- info$datos
      cat("\nValores únicos en", variable_evento, ":\n")
        print(table(datos[[variable_evento]], useNA = "always"))
      
      if (!is.null(variable_participo)) {
        cat("\nValores únicos en", variable_participo, ":\n")
        print(table(datos[[variable_participo]], useNA = "always"))
      }
      
      for (exp in variables_exposicion) {
        if (exp %in% names(datos)) {
          cat("\n--- Exposición:", exp, "---\n")
          cat("Valores originales:\n")
          print(table(datos[[exp]], useNA = "always"))
          
          convertidos &lt;- convertir_a_logico(datos[[exp]])
          cat("Valores convertidos:\n")
          print(table(convertidos, useNA = "always"))
        }
      }
    }
    
    # Calcular odds ratio y almacenar en estado reactivo
    resultados_or &lt;- calcular_odds_ratio(
      datos = info$datos,
      variable_evento = variable_evento,
      variables_exposicion = variables_exposicion,
      variable_participo = variable_participo,
      debug = FALSE #input$debug
    )
    
    # Almacenar resultados para el forest plot
    estado$resultados_or &lt;- resultados_or
    
    if (debug &amp;&amp; length(resultados_or) &gt; 0) {
      cat("\n=== RESULTADOS ODDS RATIO ===\n")
      for (exp in names(resultados_or)) {
        cat("\nExposición:", exp, "\n")
        print(resultados_or[[exp]])
      }
    }
    
    render_tabla_or(resultados_or)
  })
  
  # =========================
  # FOREST PLOT
  # =========================
  
  # Forest plot para OR
  output$forest_plot_or &lt;- renderPlot({
    req(input$ejecutar &gt; 0)
    
    info &lt;- informe()
    
    if (!is.null(info$error)) return(NULL)
    
    if (!"odds_ratio_por_exposicion" %in% info$productos) {
      return(NULL)
    }
    
    if (is.null(estado$resultados_or) || length(estado$resultados_or) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, 
                       label = "No hay datos de odds ratios para crear el forest plot", 
                       size = 6) +
               theme_void())
    }
    
    library(ggplot2)
    estado$grafico_or &lt;- crear_forest_plot(estado$resultados_or, tipo = "OR")
    
    print(estado$grafico_or)
    
  })
  
# NUEVO: Forest plot para RR
  output$forest_plot_rr &lt;- renderPlot({
    req(input$ejecutar &gt; 0)
    
    info &lt;- informe()
    
    if (!is.null(info$error)) return(NULL)
    
    if (!"riesgo_relativo_por_exposicion" %in% info$productos) {
      return(NULL)
    }
    
    if (is.null(estado$resultados_rr) || length(estado$resultados_rr) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, 
                       label = "No hay datos de riesgos relativos para crear el forest plot", 
                       size = 6) +
               theme_void())
    }
    
    library(ggplot2)
    estado$grafico_rr &lt;- crear_forest_plot(estado$resultados_rr, tipo = "RR")
    
    print(estado$grafico_rr)
    
  })
   
  
  output$plot_curva &lt;- renderPlot({
    req(input$ejecutar &gt; 0)
    
    info &lt;- informe()
    
    if (!is.null(info$error)) {
      return(NULL)
    }
    
    if (!"curva_epidemica" %in% info$productos) {
      return(NULL)
    }
    library(ggplot2)
    datos &lt;- info$datos
    var_inicio &lt;- info$vars$variable_tiempo_inicio
    
    if (!var_inicio %in% names(datos)) {
      plot.new()
      text(0.5, 0.5, 
           paste("Error: columna", var_inicio, "no encontrada"), 
           cex = 1.2, col = "red")
      return()
    }
    
    # Detectar el tipo de dato de la variable de tiempo
    dato_tiempo &lt;- datos[[var_inicio]]

  output$tabla_freq_combinada &lt;- renderUI({
    req(input$ejecutar &gt; 0)
    
    info &lt;- informe()
    
    if (!is.null(info$error)) return(NULL)
    
    vars &lt;- info$vars
    
    if (is.null(vars$sintomas)) {
      return(div(
        class = "alert alert-warning",
        "No hay variables de síntomas definidas en el YAML"
      ))
    }
    
    # Calcular frecuencia combinada de síntomas
    tabla_freq &lt;- calcular_frecuencia_combinada_sintomas(
      datos = info$datos,
      vars_sintomas = vars$sintomas
    )
    
    # Almacenar resultados para la descarga
    estado$freq_combinada &lt;- tabla_freq
    
    # Renderizar tabla
    if (!is.null(tabla_freq$error)) {
      return(div(
        class = "alert alert-warning",
        tabla_freq$error
      ))
    }
    
    # Crear tabla HTML
    filas &lt;- apply(tabla_freq, 1, function(row) {
      tags$tr(
        tags$td(row["Combinacion_sintomas"]),
        tags$td(row["Frecuencia"], style = "text-align: center;"),
        tags$td(paste0(row["Porcentaje"], "%"), style = "text-align: center;")
      )
    })
    
    tags$div(
      class = "table-responsive",
      tags$table(
        class = "table table-sm table-bordered table-striped",
        tags$thead(
          tags$tr(
            tags$th("Combinación de síntomas"),
            tags$th("Frecuencia", style = "text-align: center;"),
            tags$th("Porcentaje", style = "text-align: center;")
          )
        ),
        tags$tbody(filas)
      ),
      tags$div(
        class = "alert alert-info",
        style = "margin-top: 15px;",
        tags$small(
          tags$strong("Nota:"), " Esta tabla muestra las combinaciones de síntomas presentes en los casos, ordenadas de mayor a menor frecuencia."
        )
      )
    )
  })
    
  output$tabla_freq_simple &lt;- renderUI({
  
  req(input$ejecutar &gt; 0)
  
  info &lt;- informe()
  
  if (!is.null(info$error)) return(NULL)
  
  vars &lt;- info$vars
  
  if (is.null(vars$sintomas)) {
    return(div(
      class = "alert alert-warning",
      "No hay variables de síntomas definidas en el YAML"
    ))
  }
  
  # Calcular frecuencia simple de síntomas
  tabla_freq &lt;- calcular_frecuencia_simple_sintomas(
    datos = info$datos,
    vars_sintomas = vars$sintomas
  )
  
  # Guardar para descarga / uso posterior
  estado$freq_simple &lt;- tabla_freq
  
  # Manejo de error de la función
  if (!is.null(tabla_freq$error)) {
    return(div(
      class = "alert alert-warning",
      tabla_freq$error
    ))
  }
  
  # Crear filas HTML
  filas &lt;- apply(tabla_freq, 1, function(row) {
    tags$tr(
      tags$td(row["Sintoma"]),
      tags$td(row["Frecuencia"], style = "text-align: center;"),
      tags$td(paste0(row["Porcentaje"], "%"), style = "text-align: center;")
    )
  })
  
  # Render tabla
  tags$div(
    class = "table-responsive",
    tags$table(
      class = "table table-sm table-bordered table-striped",
      tags$thead(
        tags$tr(
          tags$th("Síntoma"),
          tags$th("Frecuencia", style = "text-align: center;"),
          tags$th("Porcentaje", style = "text-align: center;")
        )
      ),
      tags$tbody(filas)
    ),
    
    tags$div(
      class = "alert alert-info",
      style = "margin-top: 15px;",
      tags$small(
        tags$strong("Nota:"), 
        " Esta tabla muestra la frecuencia individual de cada síntoma, ordenada de mayor a menor. ",
        "El síntoma predominante puede utilizarse como base para la definición de caso clínica del brote."
      )
    )
  )
})

  
    # Verificar si hay configuración explícita de unidad de tiempo
    unidad_tiempo_config &lt;- NULL
    if (!is.null(info$vars$unidad_tiempo)) {
      unidad_tiempo_config &lt;- info$vars$unidad_tiempo
    }
    
    # Determinar automáticamente el tipo si no está configurado
    es_fecha &lt;- FALSE
    es_hora &lt;- FALSE
    
    if (!is.null(unidad_tiempo_config)) {
      # Si está configurado, usar esa información
      if (tolower(unidad_tiempo_config) %in% c("fecha", "dia", "días", "dia", "date")) {
        es_fecha &lt;- TRUE
      } else if (tolower(unidad_tiempo_config) %in% c("hora", "horas", "hour", "hours")) {
        es_hora &lt;- TRUE
      }
    } else {
      # Detectar automáticamente
      # Intentar convertir a fecha
      fecha_test &lt;- tryCatch({
        as.Date(dato_tiempo)
      }, error = function(e) NULL)
      
      if (!is.null(fecha_test) &amp;&amp; !all(is.na(fecha_test))) {
        es_fecha &lt;- TRUE
      } else if (is.numeric(dato_tiempo)) {
        es_hora &lt;- TRUE
      }
    }
    
    # Preparar datos según el tipo
    if (es_fecha) {
      # Manejo de fechas
      datos_plot &lt;- datos |&gt;
        mutate(tiempo = as.Date(.data[[var_inicio]])) |&gt;
        filter(!is.na(tiempo))
      
      if (nrow(datos_plot) == 0) {
        plot.new()
        text(0.5, 0.5, 
             "No hay datos válidos para graficar", 
             cex = 1.2, col = "gray50")
        return()
      }
      
      # Contar casos por fecha
      datos_count &lt;- datos_plot |&gt;
        group_by(tiempo) |&gt;
        summarise(n_casos = n(), .groups = "drop")
      
      # Completar todas las fechas del rango (incluir fechas sin casos)
      rango_fechas &lt;- seq(min(datos_count$tiempo), max(datos_count$tiempo), by = "1 day")
      datos_count_completo &lt;- data.frame(tiempo = rango_fechas) |&gt;
        left_join(datos_count, by = "tiempo") |&gt;
        mutate(n_casos = ifelse(is.na(n_casos), 0, n_casos))
      
      # Crear datos para líneas horizontales (sin usar crossing de tidyr)
      datos_lineas &lt;- datos_count_completo |&gt;
        filter(n_casos &gt; 1)
      
      if (nrow(datos_lineas) &gt; 0) {
        # Crear producto cartesiano manualmente
        max_casos &lt;- max(datos_count_completo$n_casos)
        datos_lineas &lt;- do.call(rbind, lapply(1:nrow(datos_lineas), function(i) {
          n &lt;- datos_lineas$n_casos[i]
          data.frame(
            tiempo = datos_lineas$tiempo[i],
            n_casos = n,
            linea = 1:(n-1)  # Líneas desde 1 hasta n-1
          )
        }))
      } else {
        datos_lineas &lt;- data.frame(tiempo = as.Date(character(0)), n_casos = numeric(0), linea = numeric(0))
      }
      
      # Crear gráfico de barras con fechas
      # width = 1 para barras pegadas, sin color de borde
      p &lt;- ggplot(datos_count_completo, aes(x = tiempo, y = n_casos)) +
        geom_col(fill = "#006666", color = "white", alpha = 0.8, width = 1)
      
      # Agregar líneas horizontales si hay datos
      if (nrow(datos_lineas) &gt; 0) {
        p &lt;- p + geom_hline(
          data = datos_lineas,
          aes(yintercept = linea),
          color = "white",
          linewidth = 0.3,
          alpha = 0.6
        )
      }
      
      p &lt;- p +
        scale_x_date(
          date_breaks = "1 day",
          date_labels = "%d/%m",
          expand = expansion(mult = c(0.05, 0.05))
        ) +
        scale_y_continuous(
          breaks = function(x) seq(0, ceiling(max(x)), by = 1),
          expand = expansion(mult = c(0, 0.05))
        ) +
        labs(
          title = "Curva epidémica",
          x = "Fecha de inicio de síntomas",
          y = "Número de casos"
        ) +
        theme_minimal(base_size = 14) +
        theme(
          plot.title = element_text(hjust = 0.5, face = "bold"),
          panel.grid.minor = element_blank(),
          axis.text.x = element_text(angle = 45, hjust = 1)
        )
      
    } else if (es_hora) {
      # Manejo de horas (numérico)
      datos_plot &lt;- datos |&gt;
        mutate(tiempo = as.numeric(.data[[var_inicio]])) |&gt;
        filter(!is.na(tiempo))
      
      if (nrow(datos_plot) == 0) {
        plot.new()
        text(0.5, 0.5, 
             "No hay datos válidos para graficar", 
             cex = 1.2, col = "gray50")
        return()
      }
      
      # Contar casos por hora
      datos_count &lt;- datos_plot |&gt;
        group_by(tiempo) |&gt;
        summarise(n_casos = n(), .groups = "drop")
      
      # Completar todas las horas del rango (incluir horas sin casos)
      rango_horas &lt;- seq(floor(min(datos_count$tiempo)), ceiling(max(datos_count$tiempo)), by = 1)
      datos_count_completo &lt;- data.frame(tiempo = rango_horas) |&gt;
        left_join(datos_count, by = "tiempo") |&gt;
        mutate(n_casos = ifelse(is.na(n_casos), 0, n_casos))
      
      # Crear datos para líneas horizontales (sin usar crossing de tidyr)
      datos_lineas &lt;- datos_count_completo |&gt;
        filter(n_casos &gt; 1)
      
      if (nrow(datos_lineas) &gt; 0) {
        # Crear producto cartesiano manualmente
        max_casos &lt;- max(datos_count_completo$n_casos)
        datos_lineas &lt;- do.call(rbind, lapply(1:nrow(datos_lineas), function(i) {
          n &lt;- datos_lineas$n_casos[i]
          data.frame(
            tiempo = datos_lineas$tiempo[i],
            n_casos = n,
            linea = 1:(n-1)  # Líneas desde 1 hasta n-1
          )
        }))
      } else {
        datos_lineas &lt;- data.frame(tiempo = numeric(0), n_casos = numeric(0), linea = numeric(0))
      }
      
      # Crear gráfico de barras con horas
      # width = 1 para barras pegadas, sin color de borde
      p &lt;- ggplot(datos_count_completo, aes(x = tiempo, y = n_casos)) +
        geom_col(fill = "#006666", color = "white", alpha = 0.8, width = 1)
      
      # Agregar líneas horizontales si hay datos
      if (nrow(datos_lineas) &gt; 0) {
        p &lt;- p + geom_hline(
          data = datos_lineas,
          aes(yintercept = linea),
          color = "white",
          linewidth = 0.3,
          alpha = 0.6
        )
      }
      
      p &lt;- p +
        scale_x_continuous(
          breaks = seq(floor(min(datos_count$tiempo)), 
                      ceiling(max(datos_count$tiempo)), 
                      by = 1),
          expand = expansion(mult = c(0.05, 0.05))
        ) +
        scale_y_continuous(
          breaks = function(x) seq(0, ceiling(max(x)), by = 1),
          expand = expansion(mult = c(0, 0.05))
        ) +
        labs(
          title = "Curva epidémica",
          x = "Horas desde inicio de síntomas",
          y = "Número de casos"
        ) +
        theme_minimal(base_size = 14) +
        theme(
          plot.title = element_text(hjust = 0.5, face = "bold"),
          panel.grid.minor = element_blank()
        )
      
    } else {
      # Si no se puede determinar el tipo
      plot.new()
      text(0.5, 0.5, 
           "No se pudo determinar el tipo de variable de tiempo\n(configure 'unidad_tiempo' en el YAML)", 
           cex = 1.2, col = "orange")
      return()
    }
    
    estado$grafico_curva &lt;- p
    
    # Retornar el gráfico
    print(p)
  })
  
  output$tabla_incubacion &lt;- renderUI({
  
  req(input$ejecutar &gt; 0)
  
  # ===================================================================
  # OPTIMIZACIÓN: Obtener info UNA SOLA VEZ y usarla consistentemente
  # ===================================================================
  
  info &lt;- informe()
  
  if (!is.null(info$error)) return(NULL)
  
  # ===================================================================
  # UNIFICACIÓN: Usar SOLO variables del objeto info
  # Eliminar variables duplicadas (sol, datos) que hacían referencia
  # a estado$solicitud y estado$datos de forma redundante
  # ===================================================================
  
  vars_solicitud &lt;- info$vars  # Única referencia a las variables
  datos_procesados &lt;- info$datos  # Única referencia a los datos (procesados)
  
  # Validar que existen las variables necesarias
  if (is.null(vars_solicitud$variable_tiempo_inicio) ||
      is.null(vars_solicitud$unidad_tiempo)) {
    
    return(div(
      class = "alert alert-warning",
      "No está definida la solicitud de incubación en el YAML"
    ))
  }
  
  # =====================================================
  # CONTROL DE CALIDAD DE FECHAS
  # AHORA USA LA MISMA FUENTE DE DATOS Y VARIABLES
  # =====================================================
  
  qc &lt;- control_calidad_fechas(
    datos = datos_procesados,  # Datos procesados (consistente)
    vars_solicitud = vars_solicitud  # Objeto completo de variables
  )
  
  # Error crítico → frena cálculo
  if (!qc$ok) {
    return(div(
      class = "alert alert-danger",
      qc$errores
    ))
  }
  
  # Advertencias → se muestran pero continúa
  advertencias_ui &lt;- NULL
  if (length(qc$advertencias) &gt; 0) {
    advertencias_ui &lt;- div(
      class = "alert alert-warning",
      tags$strong("Advertencias en datos temporales:"),
      tags$ul(lapply(qc$advertencias, tags$li))
    )
  }
  
  # =====================================================
  # CÁLCULO DE INCUBACIÓN
  # AHORA USA LA MISMA FUENTE DE DATOS Y VARIABLES
  # =====================================================
  
  res &lt;- calcular_incubacion(
    datos = datos_procesados,  # Datos procesados (consistente)
    vars_solicitud = vars_solicitud  # Objeto completo de variables
  )
  
  if (!is.null(res$error)) {
    return(div(
      class = "alert alert-warning",
      res$error
    ))
  }
  
  estado$incubacion &lt;- res
  
  # =====================================================
  # CONSTRUCCIÓN DE LA TABLA
  # Usar estructura estándar en lugar de res$resumen
  # =====================================================
  
  # Crear tabla de resultados directamente desde res
  tabla_data &lt;- data.frame(
    Indicador = c("Mediana", "Q1", "Q3", "Mínimo", "Máximo", "N válidos"),
    Valor = c(
      paste(res$mediana, res$unidad),
      paste(res$q1, res$unidad),
      paste(res$q3, res$unidad),
      paste(res$minimo, res$unidad),
      paste(res$maximo, res$unidad),
      as.character(res$n)
    ),
    stringsAsFactors = FALSE
  )
  
  filas &lt;- lapply(seq_len(nrow(tabla_data)), function(i) {
    tags$tr(
      tags$td(tabla_data$Indicador[i]),
      tags$td(tabla_data$Valor[i], style = "text-align: center;")
    )
  })
  
  tags$div(
    
    # Mostrar advertencias si existen
    advertencias_ui,
    
    class = "table-responsive",
    
    tags$table(
      class = "table table-sm table-bordered table-striped",
      tags$thead(
        tags$tr(
          tags$th("Indicador"),
          tags$th("Valor", style = "text-align: center;")
        )
      ),
      tags$tbody(filas)
    ),
    
    tags$div(
      class = "alert alert-info",
      style = "margin-top: 15px;",
      tags$strong("Interpretación epidemiológica orientativa: "),
      res$clasificacion
    )
  )
})


  
  output$debug_info &lt;- renderText({
    paste0(
      "CSV: ", if(is.null(estado$datos)) "❌" else "✓",
      "\nYAML: ", if(is.null(estado$solicitud)) "❌" else "✓",
      "\nFilas: ", if(!is.null(estado$datos)) nrow(estado$datos) else "0",
      "\nColumnas: ", if(!is.null(estado$datos)) paste(names(estado$datos), collapse=", ") else "N/A",
      "\nEjecutado: ", estado$ejecutado
    )
  })
  
  # --- LÓGICA DE DESCARGA VÍA JAVASCRIPT ---
observeEvent(input$btn_descargar_js, {
  showNotification("Preparando documento...", type = "message")
  
  # Función interna para convertir gráficos a Base64
  get_b64 &lt;- function(p) {
    if (is.null(p)) return(NULL)
    tryCatch({
      tmp &lt;- tempfile(fileext = ".png")
      ggsave(tmp, plot = p, width = 6, height = 3, dpi = 150)
      res &lt;- base64enc::base64encode(readBin(tmp, "raw", file.info(tmp)$size))
      unlink(tmp)
      paste0("data:image/png;base64,", res)
    }, error = function(e) NULL)
  }

  # 1. Procesar gráficos
  forest_or_img &lt;- get_b64(estado$grafico_or)
  forest_rr_img &lt;- get_b64(estado$grafico_rr)
  curva_img  &lt;- get_b64(estado$grafico_curva)
  
    # 2. Procesar tablas (convertir a HTML string directamente)
  tabla_desc_html &lt;- if(!is.null(estado$desc)) {
    convertir_univariada_a_html(estado$desc)
  } else { 
    "&lt;p&gt;No hay datos de descriptivos disponibles.&lt;/p&gt;"
  }
  
  tabla_tasas_html &lt;- if(!is.null(estado$resultados_tasas)) {
    convertir_tasas_a_html(estado$resultados_tasas)
  } else { 
    "&lt;p&gt;No hay datos de tasas de ataque disponibles.&lt;/p&gt;"
  }

  tabla_or_html &lt;- if(!is.null(estado$resultados_or)) {
    convertir_or_a_html(estado$resultados_or)
  } else { 
    "&lt;p&gt;No hay datos de Odds Ratio disponibles.&lt;/p&gt;"
  }
  
  tabla_rr_html &lt;- if(!is.null(estado$resultados_rr)) {
    convertir_rr_a_html(estado$resultados_rr)
  } else { 
    "&lt;p&gt;No hay datos de Riesgos Relativos disponibles.&lt;/p&gt;"
  }
  
  tabla_freq_simple_html &lt;- if(!is.null(estado$freq_simple)) {
    convertir_frec_simple_sintomas_a_html(estado$freq_simple)
  } else { 
    "&lt;p&gt;No hay datos de frecuencia de síntomas disponibles.&lt;/p&gt;"
  }
  
  tabla_freq_comb_html &lt;- if(!is.null(estado$freq_combinada)) {
    convertir_frec_combinada_a_html(estado$freq_combinada)
  } else { 
    "&lt;p&gt;No hay datos de frecuencia combinada de síntomas disponibles.&lt;/p&gt;"
  }
  
    tabla_incubacion_html &lt;- if(!is.null(estado$incubacion)) {
    convertir_incubacion_a_html(estado$incubacion)
  } else { 
    "&lt;p&gt;No hay datos de incubación disponibles.&lt;/p&gt;"
  }
 
  
  # 3. Construir el cuerpo del informe dinámicamente
  contenido &lt;- list(
    h1("Informe de Investigación de Brote", style="text-align:center; color:#2c3e50;"),
    p(tags$b("Fecha: "), format(Sys.time(), "%d/%m/%Y %H:%M")),
    hr(),
    h2("Descripción univariada"),
    HTML(tabla_desc_html),
    br()
  )
  
  # Añadir tasas
  if(!is.null(tabla_tasas_html)) {  
    contenido &lt;- c(contenido, list(
      h2("Tasas de ataque por exposición"),
      HTML(tabla_tasas_html)
    ))
  }   
  
    # Añadir RR
  if(!is.null(tabla_rr_html)) {
    contenido &lt;- c(contenido, list(
    h2("Riesgo Relativo por exposición"),
    HTML(tabla_rr_html)
    ))
  }
  
    # Añadir Forest Plot RR si existe
  if(!is.null(forest_rr_img)) {
    contenido &lt;- c(contenido, list(
      h2("Forest Plot - Riesgo Relativo"),
      img(src = forest_rr_img, style="width:60%; border:1px solid #eee;")
    ))
  }

  if(!is.null(tabla_or_html)) {  
    contenido &lt;- c(contenido, list(
      h2("Tabla de Odds Ratio"),
      HTML(tabla_or_html)
    ))
  }
  
    # Añadir Forest Plot solo si existe
  if(!is.null(forest_or_img)) {
    contenido &lt;- c(contenido, list(
      h2("Forest Plot"),
      img(src = forest_or_img, style="width:60%; border:1px solid #eee;")
    ))
  }
  
    if(!is.null(tabla_freq_simple_html)) {  
    contenido &lt;- c(contenido, list(
      h2("Frecuencia simple de síntomas"),
      HTML(tabla_freq_simple_html)
    ))
  }
  
  if(!is.null(tabla_freq_comb_html)) {  
    contenido &lt;- c(contenido, list(
      h2("Frecuencia combinada de síntomas"),
      HTML(tabla_freq_comb_html)
    ))
  }
    
    # Añadir Curva solo si existe
  if(!is.null(curva_img)) {
    contenido &lt;- c(contenido, list(
      h2("Curva Epidémica"),
      img(src = curva_img, style="width:60%; border:1px solid #eee;")
    ))
  }
  
  if(!is.null(tabla_incubacion_html)) {
    contenido &lt;- c(contenido, list(
      h2("Tiempo de incubación"),
      HTML(tabla_incubacion_html)
    ))
  }
  
  # 4. Ensamble final y descarga
  doc_final &lt;- tags$html(
    tags$head(
      tags$meta(charset = "utf-8"),
      tags$style("body{font-family:sans-serif; margin:40px; line-height:1.6;} 
                  table{width:100%; border-collapse:collapse; margin:15px 0;} 
                  th,td{border:1px solid #ddd; padding:10px; text-align:left;}
                  th{background:#f8f9fa;} h2{color:#2980b9; border-left:4px solid #2980b9; padding-left:10px; margin-top:30px;}")
    ),
    do.call(tags$body, contenido)
  )

  js$downloadFile(
    filename = paste0("informe_", format(Sys.time(), "%Y%m%d_%H%M"), ".html"),
    content = as.character(doc_final)
  )
})
}

shinyApp(ui, server)
 </code></pre>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>